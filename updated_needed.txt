function computeRanking(teamId, players) {
  const resMap = ensureTeamResults(teamId);

  // ---------- Overall stats ----------
  const base = new Map();
  players.forEach(p =>
    base.set(p, { name: p, played: 0, win: 0, lose: 0, setsFor: 0, setsAgainst: 0 })
  );

  for (let i = 0; i < players.length; i++) {
    for (let j = i + 1; j < players.length; j++) {
      const A = players[i], B = players[j];
      const k = keyPair(A, B);
      const parsed = parseScore(resMap.get(k)?.score || "");
      if (!parsed) continue;

      const aIsFirst = k.startsWith(`${A}|||`);
      const aScore = aIsFirst ? parsed.a : parsed.b;
      const bScore = aIsFirst ? parsed.b : parsed.a;

      const sA = base.get(A), sB = base.get(B);
      sA.played++; sB.played++;
      sA.setsFor += aScore; sA.setsAgainst += bScore;
      sB.setsFor += bScore; sB.setsAgainst += aScore;

      if (aScore > bScore) { sA.win++; sB.lose++; }
      else if (aScore < bScore) { sB.win++; sA.lose++; }
    }
  }

  const anyPlayed = Array.from(base.values()).some(s => s.played > 0);

  const statsArr = Array.from(base.values()).map(s => {
    const denom = s.setsFor + s.setsAgainst;
    const setRatio = denom === 0 ? 0 : (s.setsFor / denom);
    const setDiff = s.setsFor - s.setsAgainst; // overall diff (표시용)
    return { ...s, points: s.win, setRatio, setDiff };
  });

  if (!anyPlayed) {
    const out = new Map();
    players.forEach(p => {
      const s = base.get(p);
      out.set(p, {
        ...s,
        points: s.win,
        setRatio: 0,
        setDiff: 0,
        autoRank: null,
        autoReason: null,
        explain: { title: p, summary: "경기 기록 없음", rounds: [], decision: null },
        tieKey: null,
        tieMembers: null,
        tieBaseRank: null
      });
    });
    return { map: out, anyPlayed, tieGroups: [] };
  }

  function getStats(name) {
    return statsArr.find(x => x.name === name);
  }

  // score helpers for subgroup
  function getPairScore(A, B) {
    const k = keyPair(A, B);
    const parsed = parseScore(resMap.get(k)?.score || "");
    if (!parsed) return null;
    const aIsFirst = k.startsWith(`${A}|||`);
    const aScore = aIsFirst ? parsed.a : parsed.b;
    const bScore = aIsFirst ? parsed.b : parsed.a;
    return { A, B, aScore, bScore, winner: aScore > bScore ? A : (bScore > aScore ? B : null) };
  }

  function getSubgroupMetrics(group) {
    const m = new Map();
    group.forEach(p => m.set(p, { h2h: 0, subFor: 0, subAgainst: 0, subDiff: 0 }));

    const matches = [];
    for (let i = 0; i < group.length; i++) {
      for (let j = i + 1; j < group.length; j++) {
        const A = group[i], B = group[j];
        const ps = getPairScore(A, B);
        if (!ps) continue;

        matches.push(ps);

        m.get(A).subFor += ps.aScore;
        m.get(A).subAgainst += ps.bScore;
        m.get(B).subFor += ps.bScore;
        m.get(B).subAgainst += ps.aScore;

        if (ps.aScore > ps.bScore) m.get(A).h2h += 1;
        else if (ps.bScore > ps.aScore) m.get(B).h2h += 1;
      }
    }
    group.forEach(p => {
      const obj = m.get(p);
      obj.subDiff = obj.subFor - obj.subAgainst;
    });

    return { metrics: m, matches };
  }

  // ---------- Explain storage ----------
  // 선수별로 라운드 로그를 누적한 뒤, 최종 순위 산출 후 요약/결정타를 뽑아 UI에 쓰기
  const explainByPlayer = new Map();
  players.forEach(p => {
    explainByPlayer.set(p, {
      title: p,
      header: null,     // { rank, badge, recordText }
      summary: null,    // 한 줄 요약
      decision: null,   // { rule, text, vs, score }
      rounds: [],       // [ { round, pts, members, rule, table, matches, note } ... ]
    });
  });

  // 기록용: 특정 라운드에서 실제로 어떤 기준으로 “갈렸다”를 선수별 badge에 반영
  const reasonMap = new Map(); // name -> "H2H" | "DIFF" | "SF" | "TIE"

  // 라운드 로깅 유틸
  function logRoundForGroup(groupNames, pts, rule, tableRows, matches, note) {
    // tableRows: [{name, h2h, subDiff, subFor}]
    groupNames.forEach(nm => {
      explainByPlayer.get(nm).rounds.push({
        pts,
        members: [...groupNames],
        rule,
        table: tableRows,
        matches,
        note
      });
    });
  }

  // ---------- Tie-break resolver with logging ----------
  function resolveTie(groupNames, pts) {
    if (groupNames.length <= 1) return [groupNames];

    const { metrics, matches } = getSubgroupMetrics(groupNames);

    const tableRows = groupNames.map(nm => {
      const x = metrics.get(nm);
      return { name: nm, h2h: x.h2h, subDiff: x.subDiff, subFor: x.subFor };
    });

    // Round: H2H
    logRoundForGroup(
      groupNames,
      pts,
      "H2H",
      tableRows,
      matches,
      "동률자끼리 승자승으로 1차 분리"
    );

    // bucket by h2h
    const bucketsH2H = new Map();
    groupNames.forEach(nm => {
      const w = metrics.get(nm).h2h;
      if (!bucketsH2H.has(w)) bucketsH2H.set(w, []);
      bucketsH2H.get(w).push(nm);
    });
    const h2hKeys = [...bucketsH2H.keys()].sort((a, b) => b - a);
    if (h2hKeys.length > 1) groupNames.forEach(nm => reasonMap.set(nm, reasonMap.get(nm) || "H2H"));

    const resolved = [];
    for (const w of h2hKeys) {
      const bucket = bucketsH2H.get(w);
      if (bucket.length === 1) {
        resolved.push(bucket);
        continue;
      }

      // within this bucket, compute metrics again (same group scope, but safe)
      const { metrics: metrics2, matches: matches2 } = getSubgroupMetrics(bucket);
      const table2 = bucket.map(nm => {
        const x = metrics2.get(nm);
        return { name: nm, h2h: x.h2h, subDiff: x.subDiff, subFor: x.subFor };
      });

      // Round: DIFF
      logRoundForGroup(
        bucket,
        pts,
        "DIFF",
        table2,
        matches2,
        "동률자끼리 득실(subDiff)로 2차 분리"
      );

      const bucketsDiff = new Map();
      bucket.forEach(nm => {
        const d = metrics2.get(nm).subDiff;
        if (!bucketsDiff.has(d)) bucketsDiff.set(d, []);
        bucketsDiff.get(d).push(nm);
      });
      const diffKeys = [...bucketsDiff.keys()].sort((a, b) => b - a);
      if (diffKeys.length > 1) bucket.forEach(nm => reasonMap.set(nm, reasonMap.get(nm) || "DIFF"));

      for (const d of diffKeys) {
        const bucket2 = bucketsDiff.get(d);
        if (bucket2.length === 1) {
          resolved.push(bucket2);
          continue;
        }

        const { metrics: metrics3, matches: matches3 } = getSubgroupMetrics(bucket2);
        const table3 = bucket2.map(nm => {
          const x = metrics3.get(nm);
          return { name: nm, h2h: x.h2h, subDiff: x.subDiff, subFor: x.subFor };
        });

        // Round: SF
        logRoundForGroup(
          bucket2,
          pts,
          "SF",
          table3,
          matches3,
          "동률자끼리 다득(subFor)로 3차 분리"
        );

        const bucketsFor = new Map();
        bucket2.forEach(nm => {
          const f = metrics3.get(nm).subFor;
          if (!bucketsFor.has(f)) bucketsFor.set(f, []);
          bucketsFor.get(f).push(nm);
        });
        const forKeys = [...bucketsFor.keys()].sort((a, b) => b - a);
        if (forKeys.length > 1) bucket2.forEach(nm => reasonMap.set(nm, reasonMap.get(nm) || "SF"));

        for (const f of forKeys) {
          const bucket3 = bucketsFor.get(f);
          if (bucket3.length === 1) {
            resolved.push(bucket3);
            continue;
          }

          // Still tied -> recurse
          const { metrics: m4 } = getSubgroupMetrics(bucket3);
          const first = bucket3[0];
          const allSame = bucket3.every(nm => {
            const a = m4.get(nm), b = m4.get(first);
            return a.h2h === b.h2h && a.subDiff === b.subDiff && a.subFor === b.subFor;
          });

          if (allSame) {
            const sorted = [...bucket3].sort((a, b) => a.localeCompare(b, "ko"));
            sorted.forEach(nm => reasonMap.set(nm, reasonMap.get(nm) || "TIE"));
            resolved.push(sorted);
          } else {
            const deeper = resolveTie(bucket3, pts);
            deeper.forEach(g => resolved.push(g));
          }
        }
      }
    }

    return resolved;
  }

  // ---------- Build ranking blocks ----------
  statsArr.sort((x, y) => (y.points - x.points) || x.name.localeCompare(y.name, "ko"));

  const blocks = [];
  const tieGroups = [];
  let idx = 0;

  while (idx < statsArr.length) {
    const pts = statsArr[idx].points;
    const group = [];
    while (idx < statsArr.length && statsArr[idx].points === pts) {
      group.push(statsArr[idx].name);
      idx++;
    }

    if (group.length === 1) {
      blocks.push({ members: [group[0]], type: "single" });
      continue;
    }

    const resolvedGroups = resolveTie(group, pts);
    for (const g of resolvedGroups) {
      if (g.length === 1) blocks.push({ members: [g[0]], type: "single" });
      else blocks.push({ members: g, type: "tie" });
    }
  }

  // ---------- Output & finalize explain ----------
  const out = new Map();
  let rank = 1;

  for (const b of blocks) {
    if (b.members.length === 1) {
      const nm = b.members[0];
      const s = getStats(nm);

      const badge = reasonMap.get(nm) || null;

      out.set(nm, {
        ...s,
        autoRank: rank,
        autoReason: badge,
        explain: null, // 아래에서 채움
        tieKey: null,
        tieMembers: null,
        tieBaseRank: null
      });

      rank += 1;
    } else {
      const baseRank = rank;
      const members = b.members;

      const tieKey = `${teamId}|pts=${getStats(members[0]).points}|r=${baseRank}`;
      tieGroups.push({ tieKey, members, baseRank });

      for (const nm of members) {
        const s = getStats(nm);
        out.set(nm, {
          ...s,
          autoRank: baseRank,
          autoReason: "TIE",
          explain: null,
          tieKey,
          tieMembers: members,
          tieBaseRank: baseRank
        });
      }
      rank += members.length;
    }
  }

  // explain: header/summary/decision을 선수별로 만들어 붙이기
  for (const nm of players) {
    const row = out.get(nm);
    const s = getStats(nm);
    const exp = explainByPlayer.get(nm);

    const recordText = `${s.win}승 ${s.lose}패 (득실 ${s.setDiff >= 0 ? "+" : ""}${s.setDiff}, 세트득실률 ${(s.setRatio * 100).toFixed(1)}%)`;
    const badge = row.autoReason;

    exp.header = {
      rank: row.autoRank,
      badge,
      recordText
    };

    // 결정타 추출 로직(실전용 “충분히 좋은” 버전):
    // - rounds를 뒤에서부터 보며, 그 라운드에서 본인과 "바로 위/아래"를 가른 원인을 찾음
    // - 가장 최근 라운드를 결정타로 표시
    const rounds = exp.rounds;
    if (!rounds || rounds.length === 0) {
      exp.summary = "단독 순위(동률 없음)";
      exp.decision = null;
    } else {
      // 최신 라운드
      const last = rounds[rounds.length - 1];

      // 본인이 속한 (가장 좁은) 동률 멤버 목록: rounds에서 마지막 members
      const narrowMembers = last.members || [];
      const pts = last.pts;

      // 맞대결(2명 그룹)일 때는 그 경기 자체를 결정타로 잡기 좋음
      let decision = null;
      if (narrowMembers.length === 2) {
        const other = narrowMembers[0] === nm ? narrowMembers[1] : narrowMembers[0];
        const ms = (last.matches || []).find(m =>
          (m.A === nm && m.B === other) || (m.A === other && m.B === nm)
        );
        if (ms && ms.winner) {
          const score = (ms.A === nm)
            ? `${ms.aScore}-${ms.bScore}`
            : `${ms.bScore}-${ms.aScore}`;
          decision = {
            rule: "H2H",
            text: ms.winner === nm
              ? `${other}에게 맞대결 ${score} 승`
              : `${other}에게 맞대결 ${score} 패`,
            vs: other,
            score
          };
        }
      }

      if (!decision) {
        // 2명 아닌 경우: 마지막 라운드 rule로 요약
        if (last.rule === "H2H") decision = { rule: "H2H", text: `동률자끼리 승자승으로 순위 결정` };
        else if (last.rule === "DIFF") decision = { rule: "DIFF", text: `동률자끼리 득실(subDiff)로 순위 결정` };
        else if (last.rule === "SF") decision = { rule: "SF", text: `동률자끼리 다득(subFor)로 순위 결정` };
        else decision = { rule: "TIE", text: `완전 동률` };
      }

      exp.decision = decision;
      exp.summary = `${pts}승 동률 내 타이브레이크 적용`;
    }

    row.explain = exp;
    out.set(nm, row);
  }

  return { map: out, anyPlayed, tieGroups };
}



.explain { font-size: 14px; line-height: 1.4; }
.title { font-weight: 700; margin-bottom: 6px; }
.meta { color: #333; }
.record { margin-top: 4px; color: #555; }

.badge {
  display: inline-block;
  margin-left: 8px;
  padding: 2px 8px;
  border-radius: 999px;
  border: 1px solid #ddd;
  font-size: 12px;
}

.card.decision {
  margin: 10px 0;
  padding: 10px 12px;
  border: 1px solid #e6e6e6;
  border-radius: 12px;
  background: #fafafa;
}
.card .label { font-size: 12px; color: #666; margin-bottom: 4px; }
.card .text { font-weight: 700; }

.sectionTitle { margin: 12px 0 8px; font-weight: 700; }

.round { border: 1px solid #eee; border-radius: 12px; padding: 6px 10px; margin-bottom: 8px; background: #fff; }
.round summary { cursor: pointer; display: flex; justify-content: space-between; gap: 10px; }
.roundTitle { font-weight: 700; }
.sub { color: #666; font-size: 12px; }

.note { margin-top: 8px; color: #666; font-size: 12px; }

.miniTitle { margin: 10px 0 6px; font-weight: 700; font-size: 12px; color: #555; }

.miniTable { width: 100%; border-collapse: collapse; font-size: 12px; }
.miniTable th, .miniTable td { border-top: 1px solid #f0f0f0; padding: 6px 4px; text-align: center; }
.miniTable td.me { font-weight: 800; }

.matches ul { margin: 6px 0 0; padding-left: 18px; }
.muted { color: #777; }
