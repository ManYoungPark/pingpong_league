<!doctype html>
<html lang="ko">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ëŒ€ë•ë°¸ë¦¬ ëŒ€ì§„í‘œ</title>
    <style>
        :root {
            --bg: #f4f7f9;
            --card: #ffffff;
            --border: #e6e9ee;
            --text: #1f2937;
            --muted: #6b7280;
            --danger: #ef4444;
            --shadow: 0 6px 18px rgba(0, 0, 0, 0.06);
            --radius: 12px;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
            background: var(--bg);
            color: var(--text);
        }

        header {
            padding: 18px 16px 8px;
            max-width: 1400px;
            margin: 0 auto;
        }

        header h1 {
            margin: 0 0 8px;
            font-size: 20px;
            font-weight: 800;
        }

        header p {
            margin: 0;
            color: var(--muted);
            font-size: 13px;
            line-height: 1.35;
        }

        .wrap {
            max-width: 1400px;
            margin: 12px auto 24px;
            padding: 0 16px 24px;
        }

        .right-col {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .card-hd {
            padding: 12px 12px 10px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .card-hd .title {
            font-weight: 800;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pill {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid var(--border);
            color: var(--muted);
            background: #fafafa;
            white-space: nowrap;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 12px;
            align-items: center;
        }

        .controls .label {
            font-size: 13px;
            color: var(--muted);
            margin-right: 4px;
        }

        .btn {
            cursor: pointer;
            border: 1px solid var(--border);
            background: #fff;
            border-radius: 10px;
            padding: 8px 10px;
            font-size: 13px;
            font-weight: 700;
            transition: transform .05s ease, border-color .15s ease, box-shadow .15s ease;
            user-select: none;
        }

        .btn:hover {
            border-color: #cfd6e3;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn.primary {
            border-color: #cfe0ff;
            background: linear-gradient(180deg, #ffffff, #f3f7ff);
            color: #1d4ed8;
        }

        .btn.danger {
            border-color: #ffd3d3;
            background: linear-gradient(180deg, #fff, #fff5f5);
            color: #b91c1c;
        }

        .select {
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px 10px;
            font-size: 13px;
            font-weight: 700;
            background: #fff;
            cursor: pointer;
        }

        /* drop highlight */
        .droptarget {
            border: 2px dashed transparent;
            border-radius: 12px;
            transition: border-color .15s ease, background .15s ease;
        }

        .droptarget.dragover {
            border-color: #0ea5e9;
            background: rgba(14, 165, 233, 0.06);
        }

        /* name list */
        .list {
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 20px;
            min-height: 110px;
        }

        /* teams */
        .teams {
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 12px;
        }

        @media (max-width: 1100px) {
            .teams {
                grid-template-columns: 1fr;
            }
        }

        .team {
            border: 1px solid var(--border);
            border-radius: 14px;
            overflow: hidden;
            background: var(--teamBg, #fff);
        }

        .team .hd {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.65));
            backdrop-filter: blur(2px);
        }

        .team .hd .tname {
            font-weight: 900;
            font-size: 14px;
            color: #0f172a;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .team .hd .hint {
            font-size: 12px;
            color: var(--muted);
            font-weight: 700;
        }

        .team .hd .count {
            font-size: 12px;
            color: var(--muted);
            border: 1px solid var(--border);
            padding: 2px 8px;
            border-radius: 999px;
            background: #fff;
            white-space: nowrap;
        }

        .team .body {
            padding: 10px;
        }

        .team .footer {
            padding: 10px 12px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            background: rgba(250, 250, 250, 0.85);
        }

        .small {
            font-size: 12px;
            color: var(--muted);
        }

        .linkbtn {
            font-size: 12px;
            font-weight: 800;
            color: #1d4ed8;
            border: 1px solid #dbeafe;
            background: #eff6ff;
            padding: 6px 8px;
            border-radius: 10px;
            cursor: pointer;
        }

        /* chips (ì´ë¦„ + ì˜¤ë¥¸ìª½ 'ì„ íƒ') */
        .name-chip {
            border: 1px solid var(--border);
            border-radius: 14px;
            background: #fff;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            min-height: 38px;
            padding: 6px 8px;
            font-size: 12px;
            font-weight: 800;
            box-shadow: 0 1px 0 rgba(0, 0, 0, 0.02);
            transition: transform .12s ease, box-shadow .12s ease, border-color .12s ease, opacity .12s ease;
            overflow: hidden;
        }

        .name-chip:hover {
            transform: scale(1.04);
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.08);
            border-color: #cfd6e3;
        }

        .name-chip:active {
            cursor: grabbing;
        }

        .dragging {
            opacity: 0.55;
        }

        .name-chip .nm {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            text-align: left;
            font-weight: 900;
        }



        /* âœ… fixed í¬íƒˆ(ê°€ë ¤ì§ ë°©ì§€) */
        .portal {
            position: fixed;
            inset: 0;
            z-index: 99999;
            display: none;
        }

        .portal.open {
            display: block;
        }

        .portal .backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.0);
        }

        .pop {
            position: absolute;
            background: #ffffff;
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 14px 30px rgba(0, 0, 0, 0.18);
            padding: 10px;
            min-width: 240px;
            max-width: calc(100vw - 16px);
            max-height: calc(100vh - 16px);
            overflow: auto;
            -webkit-overflow-scrolling: touch;
            transform: translateZ(0);
        }

        .pop .row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 10px;
        }

        .pop .ttl {
            font-size: 12px;
            font-weight: 900;
            color: #0f172a;
        }

        .pop .close {
            cursor: pointer;
            border: 1px solid var(--border);
            background: #fff;
            border-radius: 10px;
            padding: 4px 8px;
            font-size: 12px;
            font-weight: 900;
            color: var(--muted);
        }

        .pop .grid {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 8px;
        }

        .pop .gbtn {
            cursor: pointer;
            border: 1px solid var(--border);
            background: linear-gradient(180deg, #fff, #fbfbff);
            border-radius: 10px;
            padding: 10px 0;
            font-size: 12px;
            font-weight: 900;
            color: #1d4ed8;
            transition: transform .05s ease, box-shadow .15s ease, border-color .15s ease, opacity .15s ease;
            user-select: none;
        }

        .pop .gbtn:hover {
            border-color: #cfe0ff;
            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.08);
        }

        .pop .gbtn:active {
            transform: translateY(1px);
        }

        .pop .gbtn:disabled {
            opacity: .45;
            cursor: not-allowed;
            box-shadow: none;
        }

        .pop .wide {
            grid-column: 1 / -1;
            color: #0f172a;
            background: linear-gradient(180deg, #fff, #f8fafc);
        }

        @media (max-width: 520px) {
            .pop {
                min-width: 0;
            }

            .pop .grid {
                grid-template-columns: repeat(4, minmax(0, 1fr));
            }

            .pop .wide {
                grid-column: 1 / -1;
            }
        }

        /* Round-robin */
        .rr-wrap {
            background: rgba(255, 255, 255, 0.75);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 10px;
        }

        .rr-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 2px 2px 8px;
        }

        .rr-title .ttl {
            font-weight: 900;
            font-size: 13px;
            color: #0f172a;
        }

        .rr-title .sub {
            font-size: 12px;
            color: var(--muted);
        }

        .table-scroll {
            overflow: auto;
            border: 1px solid var(--border);
            border-radius: 12px;
            background: #fff;
        }

        table.rr {
            border-collapse: collapse;
            width: 100%;
            table-layout: fixed;
            font-size: 12px;
        }

        .rr th,
        .rr td {
            border: 1px solid var(--border);
            padding: 4px 6px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: calc(100% / var(--cols));
            min-width: 80px;
        }

        .rr th.sticky {
            position: sticky;
            top: 0;
            background: #f8fafc;
            z-index: 2;
            font-weight: 900;
        }

        .rr th.leftsticky {
            position: sticky;
            left: 0;
            background: #f8fafc;
            z-index: 1;
            text-align: left;
            font-weight: 900;
        }

        .rr th.corner {
            position: sticky;
            left: 0;
            top: 0;
            z-index: 3;
            background: #f1f5f9;
            text-align: left;
        }

        .rr td.diag {
            background: #f1f5f9;
            color: var(--muted);
            font-weight: 900;
        }

        .rr select.score {
            width: 100%;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 4px 6px;
            background: #fff;
            font-weight: 800;
            cursor: pointer;
        }

        .rr td.wl {
            background: #fbfbfc;
            font-weight: 900;
        }

        .rr td.rank {
            background: #fbfbfc;
            font-weight: 900;
            width: calc(100% / var(--cols) * 1.5) !important;
        }

        /* Target the header too */
        .rr th.rank {
            width: calc(100% / var(--cols) * 1.5) !important;
        }

        .rank .crown {
            margin-right: 4px;
        }

        .rank .code {
            margin-left: 2px;
            font-size: 9px;
            color: var(--muted);
            font-weight: 900;
            border: 1px solid var(--border);
            background: #fff;
            padding: 0 4px;
            border-radius: 999px;
            letter-spacing: -0.5px;
        }

        /* Clickable Header for Moving Group */
        .rr th.clickable-head {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 4px;
        }

        .rr th.clickable-head:hover {
            background-color: #f1f5f9;
            color: #1d4ed8;
        }

        /* âœ… ë™ë¥  rank í´ë¦­ ê°€ëŠ¥ í‘œì‹œ */
        .rank.clickable {
            cursor: pointer;
            outline: 2px dashed transparent;
            transition: outline-color .15s ease, background .15s ease;
        }

        .rank.clickable:hover {
            outline-color: #0ea5e9;
            background: rgba(14, 165, 233, 0.06);
        }

        .rank .manual {
            margin-left: 6px;
            font-size: 11px;
            color: #1d4ed8;
            font-weight: 900;
            border: 1px solid #dbeafe;
            background: #eff6ff;
            padding: 1px 6px;
            border-radius: 999px;
        }

        /* =========================================
           Tournament Section Styles
           ========================================= */
        #tournament-area {
            margin-top: 40px;
            width: 100%;
            border-top: 2px dashed #e5e7eb;
            padding-top: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .tm-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            align-items: center;
        }

        .tm-panel-row {
            display: flex;
            gap: 24px;
            align-items: flex-start;
            justify-content: center;
            flex-wrap: wrap;
            width: 100%;
        }

        .tm-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            width: 100%;
            max-width: 800px;
        }

        .tm-title {
            font-weight: 1000;
            color: #111827;
            font-size: 18px;
        }

        .tm-wrap {
            position: relative;
            width: min(800px, 98vw);
            height: 600px;
            background: #fff;
            border: 1px solid #eee;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border-radius: 12px;
            overflow: hidden;
            display: block;
        }

        @media (max-width: 520px) {
            .tm-wrap {
                height: 540px;
            }
        }

        /* Bracket Nodes */
        .tm-player {
            position: absolute !important;
            width: 110px;
            height: 42px;
            border: 1px solid #3498db;
            background: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 800;
            cursor: pointer;
            border-radius: 6px;
            transition: all .15s;
            z-index: 10;
            user-select: none;
            padding: 2px 4px;
            box-sizing: border-box;
            text-align: center;
            line-height: 1.2;
        }

        .tm-player small {
            font-size: 10px;
            font-weight: 400;
            color: #64748b;
            margin-top: 2px;
            display: block;
        }

        .tm-player:hover {
            background: #3498db;
            color: white;
            border-color: #2563eb;
        }

        .tm-player:hover small {
            color: #e0f2fe;
        }

        .tm-player.empty {
            border: 1px dashed #cbd5e1;
            color: #94a3b8;
            cursor: default;
            background: #fff;
        }

        .tm-player.bye {
            border: 1px dashed #e5e7eb;
            color: #cbd5e1;
            cursor: default;
            background: #fdfdfd;
        }

        /* Winner Highlight */
        .tm-player.winner {
            background: #fffbeb !important;
            border-color: #f59e0b !important;
            color: #b45309 !important;
            box-shadow: 0 0 0 1px #f59e0b;
            z-index: 20;
        }

        .tm-player.winner small {
            color: #d97706 !important;
        }

        .tm-winner-box {
            border: 2px solid #e74c3c;
            color: #e74c3c;
            width: 130px;
            height: 48px;
            font-size: 14px;
        }

        /* SVG Lines */
        .tm-lines {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
            width: 100%;
            height: 100%;
        }

        .tm-lines path {
            transition: stroke 0.25s, stroke-width 0.25s, opacity 0.25s, stroke-dasharray 0.25s;
            stroke: #cbd5e0;
            stroke-width: 2;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
            opacity: 1;
        }

        .tm-lines path.win {
            stroke: #e74c3c !important;
            stroke-width: 4 !important;
            stroke-dasharray: none !important;
            opacity: 1;
        }

        .tm-lines path.lose {
            stroke: #94a3b8 !important;
            stroke-width: 2 !important;
            stroke-dasharray: 6 6 !important;
            opacity: 0.9;
        }

        .tm-champ-label {
            position: absolute !important;
            text-align: center;
            z-index: 10;
            width: 130px;
        }

        .tm-champ-label .label {
            font-weight: 900;
            margin-bottom: 6px;
            font-size: 14px;
            color: #e74c3c;
        }

        /* Dashboard Styles */
        .tm-dashboard {
            width: 100%;
            max-width: 900px;
            background: #fff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .tm-dash-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .tm-dash-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 800;
            color: #1f2937;
        }

        .tm-pill {
            background-color: #eef2ff;
            color: #4f46e5;
            padding: 4px 10px;
            border-radius: 9999px;
            font-size: 12px;
            font-weight: 700;
        }

        .tm-muted {
            color: #6b7280;
            font-size: 13px;
        }

        .tm-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin-bottom: 16px;
        }

        .tm-card {
            background: #f9fafb;
            border: 1px solid #f3f4f6;
            border-radius: 8px;
            padding: 12px;
        }

        .tm-card .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .tm-card .label {
            font-weight: 800;
            font-size: 14px;
            color: #374151;
        }

        .tm-card .val {
            font-weight: 900;
            font-size: 16px;
            color: #111827;
        }

        .tm-card .desc {
            font-size: 12px;
            color: #6b7280;
            line-height: 1.4;
        }

        .tm-dash-footer {
            border-top: 1px solid #f3f4f6;
            padding-top: 12px;
            text-align: center;
            font-size: 14px;
            font-weight: 600;
            color: #4b5563;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(4px);
            z-index: 100000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
        }

        .loading-overlay.open {
            display: flex;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e5e7eb;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            font-size: 16px;
            font-weight: 800;
            color: #1f2937;
        }

        /* Custom Confirm Modal */
        .modal-portal {
            position: fixed;
            inset: 0;
            z-index: 99999;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .modal-portal.open {
            display: flex;
        }

        .modal-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(2px);
        }

        .modal-card {
            position: relative;
            background: #fff;
            width: 90%;
            max-width: 400px;
            border-radius: 20px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            overflow: hidden;
            animation: modalPop 0.2s ease-out;
        }

        @keyframes modalPop {
            from {
                transform: scale(0.95);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .modal-header {
            padding: 20px 20px 10px;
            text-align: center;
        }

        .modal-title {
            margin: 0;
            font-size: 20px;
            font-weight: 800;
            color: #111827;
        }

        .modal-body {
            padding: 10px 24px 20px;
            color: #4b5563;
            font-size: 15px;
            line-height: 1.6;
        }

        .modal-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
            background: #f9fafb;
            border-radius: 12px;
            padding: 12px;
            font-size: 14px;
        }

        .modal-list li {
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .modal-list li:last-child {
            margin-bottom: 0;
        }

        .modal-footer {
            display: flex;
            border-top: 1px solid #e5e7eb;
        }

        .modal-btn {
            flex: 1;
            padding: 16px;
            font-size: 15px;
            font-weight: 700;
            background: #fff;
            border: none;
            cursor: pointer;
            transition: background 0.15s;
        }

        .modal-btn:hover {
            background: #f9fafb;
        }

        .modal-btn.cancel {
            color: #6b7280;
            border-right: 1px solid #e5e7eb;
        }

        .modal-btn.confirm {
            color: #2563eb;
        }

        .modal-btn.confirm:hover {
            background: #eff6ff;
        }

        /* Final Summary Styles */
        .final-summary {
            width: min(800px, 95vw);
            background: linear-gradient(135deg, #fff 0%, #fef9c3 100%);
            border: 2px solid #fbbf24;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 40px;
            box-shadow: 0 10px 25px -5px rgba(251, 191, 36, 0.3);
            text-align: center;
            display: none;
            /* Hidden by default */
            animation: popIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .final-summary.show {
            display: block;
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: scale(0.8) translateY(20px);
            }

            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .summary-title {
            font-size: 24px;
            font-weight: 900;
            color: #b45309;
            margin-bottom: 20px;
            text-shadow: 1px 1px 0 #fff;
            letter-spacing: -0.5px;
        }

        .summary-content {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .summary-card {
            flex: 1;
            min-width: 280px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .summary-card.upper {
            background: linear-gradient(to bottom, #fff, #fffbeb);
        }

        .summary-card.lower {
            background: linear-gradient(to bottom, #fff, #f0f9ff);
            border-color: #bae6fd;
        }

        .card-title {
            font-size: 16px;
            font-weight: 800;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid rgba(0, 0, 0, 0.05);
        }

        .summary-card.upper .card-title {
            color: #b45309;
        }

        .summary-card.lower .card-title {
            color: #0369a1;
        }

        .rank-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 700;
            color: #374151;
            padding: 4px 8px;
            border-radius: 6px;
        }

        .rank-row.winner {
            background: rgba(251, 191, 36, 0.1);
            color: #000;
            font-size: 16px;
        }

        .rank-row.runner-up {
            background: rgba(243, 244, 246, 0.5);
        }

        .rank-row .icon {
            margin-right: 8px;
            font-size: 1.2em;
        }

        .rank-row .label {
            width: 60px;
            text-align: left;
            opacity: 0.7;
            font-size: 0.9em;
        }

        .rank-row .name {
            flex: 1;
            text-align: left;
            font-weight: 800;
        }
    </style>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
</head>

<body>
    <header>
        <h1>ëŒ€ë•ë°¸ë¦¬ ëŒ€ì§„í‘œ <span id="headerDate" contenteditable="true"
                style="font-size: 15px; font-weight: 500; color: #6b7280; margin-left: 8px; cursor: pointer; border-bottom: 1px dashed #d1d5db;"
                title="í´ë¦­í•˜ì—¬ ë‚ ì§œ ìˆ˜ì •"></span></h1>
        <p>
            ê²°ê³¼ë¥¼ ì…ë ¥í•˜ë©´ <b>ìŠ¹-íŒ¨</b>, <b>ìˆœìœ„</b>ê°€ ìë™ ê³„ì‚°ë©ë‹ˆë‹¤.
            ë™ë¥ ì´ ëê¹Œì§€ ì•ˆ í’€ë¦¬ë©´ <b>ê³µë™ nìœ„(TIE)</b>ë¡œ í‘œì‹œë˜ê³ , <b>ìˆœìœ„ ì¹¸ì„ ëˆŒëŸ¬</b> ì‚¬ìš©ìê°€ ìµœì¢… ìˆœìœ„ë¥¼ í™•ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        </p>
    </header>

    <div class="wrap">
        <div class="right-col">

            <section class="card" id="card-settings">
                <div class="card-hd">
                    <div class="title">ì„¤ì •</div>
                    <span class="pill">ì¡° ê°œìˆ˜ / ê²½ê¸° ë°©ì‹</span>
                </div>
                <div class="controls">
                    <span class="label">ì¡° ê°œìˆ˜:</span>
                    <button class="btn primary" data-g="2">2ì¡°</button>
                    <button class="btn primary" data-g="3">3ì¡°</button>
                    <button class="btn primary" data-g="4">4ì¡°</button>
                    <button class="btn primary" data-g="5">5ì¡°</button>
                    <button class="btn primary" data-g="6">6ì¡°</button>

                    <span class="label" style="margin-left:8px;">ê²½ê¸°:</span>
                    <select class="select" id="matchFormat">
                        <option value="bo3">3íŒ 2ì„ ìŠ¹</option>
                        <option value="bo5">5íŒ 3ì„ ìŠ¹</option>
                    </select>

                    <button type="button" class="btn" onclick="openReset()">ğŸ”„ ì´ˆê¸°í™”</button>
                    <button type="button" class="btn" onclick="runAutoTestScenario()">ğŸ§ª í…ŒìŠ¤íŠ¸(3ì¡°)</button>
                    <button type="button" class="btn" onclick="runAutoTestScenario4Groups()">ğŸ² í…ŒìŠ¤íŠ¸(4ì¡° ëœë¤)</button>
                    <!-- <button type="button" class="btn primary" id="btn-gen-tournament">ğŸ† ë³¸ì„  í† ë„ˆë¨¼íŠ¸ ìƒì„±</button> -->
                    <button type="button" class="btn" id="btn-show-sample">ğŸ‘€ ì˜ˆì‹œ ë³´ê¸°</button>
                </div>
        </div>
        </section>

        <section class="card" id="card-pool">
            <div class="card-hd">
                <div class="title" style="display:flex; align-items:center; gap:8px;">
                    ì´ë¦„ ëª©ë¡ <span class="pill" id="poolCount">0ëª…</span>
                    <button type="button" class="btn"
                        style="padding:4px 8px; font-size:11px; background:#eff6ff; color:#1d4ed8; border-color:#bfdbfe;"
                        onclick="addPlayer()">+ ì´ë¦„ ì¶”ê°€</button>
                    <button type="button" class="btn"
                        style="padding:4px 8px; font-size:11px; background:#f0fdf4; color:#15803d; border-color:#bbf7d0;"
                        onclick="downloadNamesJSON()" title="í˜„ì¬ ëª…ë‹¨ì„ names.jsonìœ¼ë¡œ ë‹¤ìš´ë¡œë“œ">ğŸ’¾ ì €ì¥</button>
                </div>
                <span class="pill">ì—¬ê¸°ë¡œ ë“œë¡­í•˜ë©´ íšŒìˆ˜</span>
            </div>
            <div class="list droptarget" id="pool"></div>
        </section>

        <section class="card" id="card-teams">
            <div class="card-hd">
                <div class="title">ì¡° í…Œì´ë¸” <span class="pill" id="teamInfo">0ì¡°</span></div>
                <!-- <span class="pill">ì¡° ì¹´ë“œì— ë“œë¡­</span> -->
                <button class="linkbtn" id="openHelpBtn" style="font-size:12px;">ğŸ’¡ ë„ì›€ë§: ë™ë¥  ì²˜ë¦¬ ê¸°ì¤€ & ì˜ˆì‹œ (ë™ë¥  ì½”ë“œ: H2H Â· SD
                    Â· SF Â· TIE(ê³µë™))</button>
            </div>
            <div class="teams" id="teams"></div>
            <div style="padding:12px; text-align:center; border-top:1px solid var(--border);">
                <!-- <button class="linkbtn" id="openHelpBtn" style="font-size:13px;">ğŸ’¡ ë„ì›€ë§: ë™ë¥  ì²˜ë¦¬ ê¸°ì¤€ & ì˜ˆì‹œ</button> -->
                <button type="button" class="btn primary" id="btn-gen-tournament"
                    style="width:100%; padding: 12px; font-size:15px;">ğŸ† ë³¸ì„  í† ë„ˆë¨¼íŠ¸ ìƒì„±</button>
            </div>
        </section>

    </div>
    </div>

    <!-- âœ… ì¡° ì„ íƒ í¬íƒˆ -->
    <div class="portal" id="assignPortal" aria-hidden="true">
        <div class="backdrop" id="assignBackdrop"></div>
        <div class="pop" id="assignPop" role="dialog" aria-modal="true">
            <div class="row">
                <div class="ttl" id="assignTitle">ì¡° ì„ íƒ</div>
                <button class="close" type="button" id="assignClose">ë‹«ê¸°</button>
            </div>
            <div class="grid" id="assignGrid"></div>
        </div>
    </div>

    <!-- âœ… ìˆœìœ„ í™•ì • í¬íƒˆ -->
    <div class="portal" id="rankPortal" aria-hidden="true">
        <div class="backdrop" id="rankBackdrop"></div>
        <div class="pop" id="rankPop" role="dialog" aria-modal="true">
            <div class="row">
                <div class="ttl" id="rankTitle">ìˆœìœ„ í™•ì •</div>
                <button class="close" type="button" id="rankClose">ë‹«ê¸°</button>
            </div>
            <div class="grid" id="rankGrid"></div>
        </div>
    </div>

    <!-- âœ… ë„ì›€ë§ í¬íƒˆ -->
    <div class="portal" id="helpPortal" aria-hidden="true">
        <div class="backdrop" id="helpBackdrop"></div>
        <div class="pop" id="helpPop" role="dialog" aria-modal="true" style="max-width:400px;">
            <div class="row">
                <div class="ttl">ë™ë¥  ì²˜ë¦¬ ê¸°ì¤€ & ì˜ˆì‹œ</div>
                <button class="close" type="button" id="helpClose">ë‹«ê¸°</button>
            </div>
            <div style="padding:10px 14px; font-size:13px; line-height:1.6; color:#333;">
                <h3 style="margin:0 0 8px; font-size:14px; font-weight:800; color:#111;">1. ë™ë¥  ì²˜ë¦¬ ê¸°ì¤€ (ìˆœìœ„ ì‚°ì • ìš°ì„ ìˆœìœ„)</h3>
                <p style="margin:0 0 8px; color:#555;">ë¦¬ê·¸ì „(ì¡°ë³„ ê²½ê¸°)ì—ì„œ ì°¸ê°€ìì˜ ìˆœìœ„ëŠ” ì•„ë˜ ê¸°ì¤€ì„ <b>ìœ„ì—ì„œë¶€í„° ìˆœì°¨ì ìœ¼ë¡œ ì ìš©</b>í•˜ì—¬ ê²°ì •í•œë‹¤.</p>
                <ol style="margin:0 0 20px; padding-left:20px; color:#4b5563;">
                    <li style="margin-bottom:4px;"><b>ìŠ¹ì  (Wins)</b><br />ìŠ¹ë¦¬ íšŸìˆ˜ê°€ ë§ì€ ì°¸ê°€ìë¥¼ ìƒìœ„ ìˆœìœ„ë¡œ í•œë‹¤.</li>
                    <li style="margin-bottom:4px;"><b>ìŠ¹ììŠ¹ (Head-to-Head)</b><br />ë™ë¥ ìê°€ <b>2ëª…ì¼ ê²½ìš°ì—ë§Œ ì ìš©</b>í•˜ë©°, ë‘ ì°¸ê°€ì ê°„
                        ë§ëŒ€ê²°ì—ì„œ ìŠ¹ë¦¬í•œ ì°¸ê°€ìë¥¼ ìƒìœ„ ìˆœìœ„ë¡œ í•œë‹¤.</li>
                    <li style="margin-bottom:4px;"><b>ì„¸íŠ¸ ë“ì‹¤ (Set Difference, SD)</b><br />ëª¨ë“  ê²½ê¸°ì—ì„œì˜ <b>ì´ ì„¸íŠ¸ ë“ìˆ˜ì—ì„œ ì´ ì„¸íŠ¸ ì‹¤ìˆ˜ë¥¼
                            ëº€ ê°’</b>ì´ í° ì°¸ê°€ìë¥¼ ìƒìœ„ ìˆœìœ„ë¡œ í•œë‹¤.</li>
                    <li style="margin-bottom:4px;"><b>ì„¸íŠ¸ ë‹¤ë“ (Set For, SF)</b><br />ì„¸íŠ¸ ë“ì‹¤ì´ ê°™ì€ ê²½ìš°, <b>ì´ ì„¸íŠ¸ ë“ìˆ˜ê°€ ë§ì€ ì°¸ê°€ì</b>ë¥¼
                        ìƒìœ„ ìˆœìœ„ë¡œ í•œë‹¤.</li>
                    <li><b>ê³µë™ ìˆœìœ„ (Tie)</b><br />ìœ„ ëª¨ë“  ê¸°ì¤€ì´ ë™ì¼í•  ê²½ìš°, í•´ë‹¹ ì°¸ê°€ìë“¤ì€ <b>ê³µë™ ìˆœìœ„</b>ë¡œ ì²˜ë¦¬í•œë‹¤.<br />(í•„ìš” ì‹œ ì£¼ìµœ ì¸¡ì´ ë³„ë„ì˜ ê²°ì • ë°©ì‹
                        ë˜ëŠ” ì¶”ê°€ ê²½ê¸°ë¡œ ìˆœìœ„ë¥¼ í™•ì •í•  ìˆ˜ ìˆë‹¤.)</li>
                </ol>

                <h3 style="margin:0 0 8px; font-size:14px; font-weight:800; color:#111;">2. ë™ë¥  ì²˜ë¦¬ ì˜ˆì‹œ</h3>
                <div
                    style="background:#f8fafc; border:1px solid #e2e8f0; border-radius:8px; padding:12px; color:#4b5563; margin-bottom:20px;">
                    <h4 style="margin:0 0 6px; font-size:13px; font-weight:800;">ì˜ˆì‹œ ìƒí™©</h4>
                    <p style="margin:0 0 10px;">A, B, C ì„¸ ëª…ì˜ ì°¸ê°€ìê°€ ê°ê° <b>1ìŠ¹ 1íŒ¨</b>ë¡œ ë™ë¥ ì¸ ê²½ìš°</p>

                    <h4 style="margin:0 0 6px; font-size:13px; font-weight:800;">ê²½ê¸° ê²°ê³¼</h4>
                    <ul style="margin:0 0 10px; padding-left:20px;">
                        <li>A vs B : A ìŠ¹ (2â€“0)</li>
                        <li>B vs C : B ìŠ¹ (2â€“1)</li>
                        <li>C vs A : C ìŠ¹ (2â€“1)</li>
                    </ul>

                    <h4 style="margin:0 0 6px; font-size:13px; font-weight:800;">íŒë‹¨ ê³¼ì •</h4>
                    <ol style="margin:0 0 10px; padding-left:20px;">
                        <li><b>ìŠ¹ì </b>: ì„¸ ì°¸ê°€ì ëª¨ë‘ 1ìŠ¹ 1íŒ¨ â†’ ë™ë¥ </li>
                        <li><b>ìŠ¹ììŠ¹</b>: ì„¸ ëª…ì´ ì„œë¡œ ìˆœí™˜ ìŠ¹ë¦¬ë¥¼ ê¸°ë¡í•˜ì—¬ ì ìš© ë¶ˆê°€<br />(AëŠ” Bì—ê²Œ ìŠ¹ë¦¬, BëŠ” Cì—ê²Œ ìŠ¹ë¦¬, CëŠ” Aì—ê²Œ ìŠ¹ë¦¬)</li>
                        <li><b>ì„¸íŠ¸ ë“ì‹¤ (SD) ë¹„êµ</b>
                            <table
                                style="width:100%; margin-top:6px; border-collapse:collapse; font-size:12px; background:#fff;">
                                <tr style="background:#f1f5f9; border-bottom:1px solid #e2e8f0;">
                                    <th style="padding:4px; border:1px solid #e2e8f0;">ì°¸ê°€ì</th>
                                    <th style="padding:4px; border:1px solid #e2e8f0;">ì„¸íŠ¸ ë“</th>
                                    <th style="padding:4px; border:1px solid #e2e8f0;">ì„¸íŠ¸ ì‹¤</th>
                                    <th style="padding:4px; border:1px solid #e2e8f0;">ì„¸íŠ¸ ë“ì‹¤</th>
                                </tr>
                                <tr>
                                    <td style="padding:4px; border:1px solid #e2e8f0; text-align:center;">A</td>
                                    <td style="padding:4px; border:1px solid #e2e8f0; text-align:center;">3</td>
                                    <td style="padding:4px; border:1px solid #e2e8f0; text-align:center;">2</td>
                                    <td
                                        style="padding:4px; border:1px solid #e2e8f0; text-align:center; font-weight:bold; color:#1d4ed8;">
                                        +1</td>
                                </tr>
                                <tr>
                                    <td style="padding:4px; border:1px solid #e2e8f0; text-align:center;">B</td>
                                    <td style="padding:4px; border:1px solid #e2e8f0; text-align:center;">2</td>
                                    <td style="padding:4px; border:1px solid #e2e8f0; text-align:center;">3</td>
                                    <td
                                        style="padding:4px; border:1px solid #e2e8f0; text-align:center; font-weight:bold; color:#ef4444;">
                                        -1</td>
                                </tr>
                                <tr>
                                    <td style="padding:4px; border:1px solid #e2e8f0; text-align:center;">C</td>
                                    <td style="padding:4px; border:1px solid #e2e8f0; text-align:center;">3</td>
                                    <td style="padding:4px; border:1px solid #e2e8f0; text-align:center;">3</td>
                                    <td
                                        style="padding:4px; border:1px solid #e2e8f0; text-align:center; font-weight:bold;">
                                        0</td>
                                </tr>
                            </table>
                        </li>
                    </ol>

                    <h4 style="margin:0 0 6px; font-size:13px; font-weight:800;">ìµœì¢… ìˆœìœ„</h4>
                    <ul style="margin:0; padding-left:20px;">
                        <li><b>1ìœ„</b> : A (ì„¸íŠ¸ ë“ì‹¤ +1)</li>
                        <li><b>2ìœ„</b> : C (ì„¸íŠ¸ ë“ì‹¤ 0)</li>
                        <li><b>3ìœ„</b> : B (ì„¸íŠ¸ ë“ì‹¤ -1)</li>
                    </ul>
                </div>

                <h3 style="margin:0 0 8px; font-size:14px; font-weight:800; color:#111;">3. ì°¸ê³  ì‚¬í•­</h3>
                <ul style="margin:0; padding-left:20px; color:#4b5563;">
                    <li style="margin-bottom:4px;"><b>3ëª… ì´ìƒ ë™ë¥ ì¼ ê²½ìš°</b>, ìŠ¹ììŠ¹ ê¸°ì¤€ì€ ì ìš©í•˜ì§€ ì•Šê³  ì„¸íŠ¸ ë“ì‹¤ë¶€í„° ë¹„êµí•œë‹¤.</li>
                    <li style="margin-bottom:4px;">ëª¨ë“  ì„¸íŠ¸ ë“ì‹¤ ë° ì„¸íŠ¸ ë“ìˆ˜ëŠ” <b>í•´ë‹¹ ì¡°ì˜ ëª¨ë“  ê²½ê¸° ê²°ê³¼ë¥¼ í•©ì‚°</b>í•˜ì—¬ ê³„ì‚°í•œë‹¤.
                    </li>
                    <li>ê³µë™ ìˆœìœ„ê°€ ë°œìƒí•  ê²½ìš°, ìˆœìœ„ í‘œì—ëŠ” <b>â€œê³µë™ â—‹ìœ„â€</b>ë¡œ í‘œì‹œí•œë‹¤.</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- âœ… ì¡° ì´ë™ í¬íƒˆ (New) -->
    <div class="portal" id="movePortal" aria-hidden="true">
        <div class="backdrop" id="moveBackdrop"></div>
        <div class="pop" id="movePop" role="dialog" aria-modal="true">
            <div class="row">
                <div class="ttl" id="moveTitle">ì¡° ì´ë™</div>
                <button class="close" type="button" id="moveClose">ë‹«ê¸°</button>
            </div>
            <div class="grid" id="moveGrid"></div>
        </div>
    </div>

    <!-- âœ… ì ìˆ˜ ì…ë ¥ í¬íƒˆ (New) -->
    <div class="portal" id="scorePortal" aria-hidden="true">
        <div class="backdrop" id="scoreBackdrop"></div>
        <div class="pop" id="scorePop" role="dialog" aria-modal="true">
            <div class="row">
                <div class="ttl" id="scoreTitle">ì ìˆ˜ ì…ë ¥</div>
                <button class="close" type="button" id="scoreClose">ë‹«ê¸°</button>
            </div>
            <div class="grid" id="scoreGrid"></div>
        </div>
    </div>

    <!-- âœ… Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text" id="loadingText">ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤...</div>
    </div>

    <!-- âœ… Custom Confirm Modal -->
    <div id="customModal" class="modal-portal">
        <div class="modal-backdrop" id="customModalBackdrop"></div>
        <div class="modal-card">
            <div class="modal-header">
                <h3 class="modal-title" id="modalTitle">ì•Œë¦¼</h3>
            </div>
            <div class="modal-body">
                <div id="modalMessage">ë‚´ìš©</div>
                <ul id="modalList" class="modal-list" style="display:none;"></ul>
            </div>
            <div class="modal-footer">
                <button type="button" class="modal-btn cancel" id="modalCancelBtn">ì·¨ì†Œ</button>
                <button type="button" class="modal-btn confirm" id="modalConfirmBtn">í™•ì¸</button>
            </div>
        </div>
    </div>

    <!-- TOURNAMENT SECTION -->
    <div id="tournament-area" style="display:none;">
        <!-- Final Summary Section -->
        <div id="final-summary" class="final-summary">
            <div class="summary-title">ğŸ† ìµœì¢… ê²°ê³¼ ë°œí‘œ ğŸ†</div>
            <div class="summary-content">
                <!-- Upper Result -->
                <div class="summary-card upper">
                    <div class="card-title">ìƒìœ„ í† ë„ˆë¨¼íŠ¸</div>
                    <div class="rank-row winner">
                        <span class="icon">ğŸ†</span>
                        <span class="label">ìš°ìŠ¹</span>
                        <span class="name" id="sum-u-1">-</span>
                    </div>
                    <div class="rank-row runner-up">
                        <span class="icon">ğŸ¥ˆ</span>
                        <span class="label">ì¤€ìš°ìŠ¹</span>
                        <span class="name" id="sum-u-2">-</span>
                    </div>
                    <div class="rank-row third">
                        <span class="icon">ğŸ¥‰</span>
                        <span class="label">3ìœ„</span>
                        <span class="name" id="sum-u-3">-</span>
                    </div>
                </div>
                <!-- Lower Result -->
                <div class="summary-card lower">
                    <div class="card-title">í•˜ìœ„ í† ë„ˆë¨¼íŠ¸</div>
                    <div class="rank-row winner">
                        <span class="icon">ğŸ†</span>
                        <span class="label">ìš°ìŠ¹</span>
                        <span class="name" id="sum-l-1">-</span>
                    </div>
                    <div class="rank-row runner-up">
                        <span class="icon">ğŸ¥ˆ</span>
                        <span class="label">ì¤€ìš°ìŠ¹</span>
                        <span class="name" id="sum-l-2">-</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="tm-controls">
            <h2 class="tm-title">ğŸ† ë³¸ì„  í† ë„ˆë¨¼íŠ¸</h2>
            <button type="button" class="btn" onclick="captureResultImage()" style="margin-left:auto;">ğŸ“· ì´ë¯¸ì§€
                ì €ì¥</button>
        </div>

        <div id="tm-dashboard" class="tm-dashboard" style="margin-bottom: 30px;">
            <!-- Dashboard content will be injected here -->
        </div>

        <div class="tm-panel-row">
            <div class="tm-panel">
                <div class="tm-title" id="tm-titleUpper">ìƒìœ„ í† ë„ˆë¨¼íŠ¸</div>
                <div id="tm-wrap-upper" class="tm-wrap">
                    <svg id="tm-lines-upper" class="tm-lines"></svg>
                </div>
            </div>

            <div class="tm-panel">
                <div class="tm-title" id="tm-titleLower">í•˜ìœ„ í† ë„ˆë¨¼íŠ¸</div>
                <div id="tm-wrap-lower" class="tm-wrap">
                    <svg id="tm-lines-lower" class="tm-lines"></svg>
                </div>
            </div>
        </div>
    </div>

    <script>
        // âœ… Date Initialization (YYYYë…„ MMì›” DDì¼ (ìš”ì¼))
        (function initDate() {
            const today = new Date();
            const year = today.getFullYear();
            const month = today.getMonth() + 1;
            const date = today.getDate();
            const days = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "];
            const dayName = days[today.getDay()];

            const dateStr = `${year}ë…„ ${month}ì›” ${date}ì¼ (${dayName})`;
            const el = document.getElementById("headerDate");
            if (el) el.textContent = dateStr;
        })();

        // âœ… Load Names: LocalStorage -> names.json (Async) -> Default Fallback
        const STORAGE_KEY = 'my_tournament_names_v1';

        // 1. Fallback Defaults (Network Error / File protocol)
        const DEFAULT_NAMES = [
            "ë°•ë§Œì˜", "ì´ì •ìš°", "ê¹€ê²½íƒœ", "ë°•ë³‘ì¬", "ì•ˆì„±ëŒ€", "ìœ í˜¸ì„±", "ì¡°ë³µì—°", "ê°•í¬ì² ",
            "ê³½ì€ìˆ™", "ê¶Œì˜ê·œ", "ê¹€ë¯¸ê²½", "ê¹€ì„±í˜¸", "ê¹€ì„¸ì¤‘", "ê¹€ìˆœë™", "ê¹€ì˜ë¯¼", "ê¹€í˜•ì°¬",
            "ê¹€í™ì„", "ë¥˜ê³„ì—´", "ë¥˜ì„±ë¬¸", "ë°•ë•ë¡€", "ë°•ìˆ˜ìš©", "ë°•í˜œë€", "ë°±ë‚™ì²œ", "ì„œìƒêµ­",
            "ì†¡ê´‘ìš©", "ê¹€ì¢…íƒ", "ì˜¤ì¥ì§„", "ìœ¤êµì°¬", "ì´êµíƒ", "ì´ì˜ìˆ™", "ì„ê·œí˜¸", "ì •ê²½ì", "ì •ì„ ì² ", "ì •ì§„ìˆ™", "ì¡°ìƒë°°", "ìµœë§¤ì™„",
            "ë°•í˜„ì‹ ", "í™ìˆœê´€", "í™í˜„ìˆ™"
        ];

        // Initialize with Defaults first
        let INITIAL_NAMES = [...DEFAULT_NAMES];

        // 2. Try LocalStorage (User's custom list)
        let hasLocalStorage = false;
        try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (raw) {
                const stored = JSON.parse(raw);
                if (Array.isArray(stored) && stored.length > 0) {
                    INITIAL_NAMES = stored;
                    hasLocalStorage = true;
                }
            }
        } catch (e) {
            console.error("LS load failed", e);
        }

        INITIAL_NAMES.sort((a, b) => a.localeCompare(b, 'ko'));

        // 3. Try Fetching names.json (Async) - ONLY if LS is empty
        // If the user has already customized the list (LS exists), we do NOT overwrite it with the file.
        // This ensures 'Add Player' changes are respected.
        (async function loadNamesFromJson() {
            if (hasLocalStorage) return; // Skip if user has data

            try {
                const response = await fetch('names.json');
                if (!response.ok) throw new Error("JSON load failed");
                const jsonNames = await response.json();

                if (Array.isArray(jsonNames) && jsonNames.length > 0) {
                    INITIAL_NAMES = jsonNames;
                    INITIAL_NAMES.sort((a, b) => a.localeCompare(b, 'ko'));

                    // Since this is async, we need to refresh the pool UI if it was already rendered
                    renderPool();
                    console.log("Loaded names from names.json");
                }
            } catch (err) {
                console.warn("names.json fetch failed (likely local file protocol). Using defaults.", err);
            }
        })();

        function saveNames() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(INITIAL_NAMES));
            } catch (e) { console.error("Save failed", e); }
        }

        function addPlayer() {
            const name = prompt("ì¶”ê°€í•  ì„ ìˆ˜ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:");
            if (!name || !name.trim()) return;
            const cleanName = name.trim();

            if (INITIAL_NAMES.includes(cleanName)) {
                alert("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì´ë¦„ì…ë‹ˆë‹¤!");
                return;
            }

            INITIAL_NAMES.push(cleanName);
            INITIAL_NAMES.sort((a, b) => a.localeCompare(b, 'ko'));
            saveNames();

            // Register to state if not exists
            if (!state.has(cleanName)) {
                state.set(cleanName, { where: "pool" });
            }

            renderPool();
            alert(`'${cleanName}' ì„ ìˆ˜ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }

        function downloadNamesJSON() {
            const dataStr = JSON.stringify(INITIAL_NAMES, null, 2); // Pretty print
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);

            const a = document.createElement("a");
            a.href = url;
            a.download = "names.json";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        const TEAM_COLORS = ["#fff7ed", "#f0f9ff", "#f0fdf4", "#f5f3ff", "#fdf2f8", "#fefce8"];
        const SCORE_OPTIONS = {
            bo3: ["", "2-0", "2-1", "1-2", "0-2"],
            bo5: ["", "3-0", "3-1", "3-2", "2-3", "1-3", "0-3"]
        };

        const state = new Map();               // name -> {where:"pool"} or {where:"team", teamId}
        state.groupsCount = 0;

        const resultsByTeam = new Map();       // teamId -> Map("A|||B" -> {score:"x-y" in key-order})

        // âœ… ì‚¬ìš©ìê°€ í™•ì •í•œ ìˆœìœ„: teamId -> Map(name -> finalRankNumber)
        const manualRankByTeam = new Map();
        function ensureManual(teamId) {
            if (!manualRankByTeam.has(teamId)) manualRankByTeam.set(teamId, new Map());
            return manualRankByTeam.get(teamId);
        }

        const poolEl = document.getElementById("pool");
        const teamsEl = document.getElementById("teams");
        const poolCountEl = document.getElementById("poolCount");
        const teamInfoEl = document.getElementById("teamInfo");
        const matchFormatEl = document.getElementById("matchFormat");
        // const resetBtn = document.getElementById("resetBtn"); 
        // ID removed in HTML, so we mock it to prevent crash if listener exists
        const resetBtn = { addEventListener: () => { } };

        function openReset() {
            if (!confirm("ëª¨ë“  ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ì´ì „ ë°°ì •/ì ìˆ˜ ì‚­ì œë¨)")) return;
            initState();
            renderPool();
            createTeams(4); // Default 4 groups

            // clear tournament area if open
            const area = document.getElementById("tournament-area");
            if (area) area.style.display = "none";
        }

        function setText(el, txt) { el.textContent = txt; }

        /* ========= ê³µí†µ: fixed í¬íƒˆ ìœ„ì¹˜ ì¡ê¸° ========= */
        function placePop(popEl, anchorEl) {
            const pad = 8;
            const gap = 8;
            const r = anchorEl.getBoundingClientRect();

            popEl.style.left = "0px";
            popEl.style.top = "0px";
            popEl.style.visibility = "hidden";

            const pw = popEl.offsetWidth;
            const ph = popEl.offsetHeight;

            let left = r.right - pw;
            let top = r.bottom + gap;

            left = Math.max(pad, Math.min(left, window.innerWidth - pw - pad));

            const spaceBelow = window.innerHeight - r.bottom;
            const spaceAbove = r.top;
            if (spaceBelow < ph + gap && spaceAbove > ph + gap) {
                top = r.top - ph - gap;
            }
            top = Math.max(pad, Math.min(top, window.innerHeight - ph - pad));

            popEl.style.left = `${Math.round(left)}px`;
            popEl.style.top = `${Math.round(top)}px`;
            popEl.style.visibility = "visible";
        }

        /* ========= ì¡° ì„ íƒ í¬íƒˆ ========= */
        const assignPortal = document.getElementById("assignPortal");
        const assignBackdrop = document.getElementById("assignBackdrop");
        const assignPop = document.getElementById("assignPop");
        const assignGrid = document.getElementById("assignGrid");
        const assignClose = document.getElementById("assignClose");
        const assignTitle = document.getElementById("assignTitle");
        let currentAssignName = null;
        let currentAssignAnchor = null;

        function isAssignOpen() { return assignPortal.classList.contains("open"); }
        function closeAssign() {
            assignPortal.classList.remove("open");
            assignPortal.setAttribute("aria-hidden", "true");
            currentAssignName = null;
            currentAssignAnchor = null;
        }
        function openAssign(anchorEl, name) {
            if (!state.groupsCount || state.groupsCount < 1) return;
            currentAssignName = name;
            currentAssignAnchor = anchorEl;

            assignTitle.textContent = `ì¡° ì„ íƒ Â· ${name}`;
            assignGrid.innerHTML = "";

            for (let i = 1; i <= state.groupsCount; i++) {
                const b = document.createElement("button");
                b.type = "button";
                b.className = "gbtn";
                b.textContent = `${i}ì¡°`;
                b.addEventListener("click", (e) => {
                    e.stopPropagation();
                    moveToTeam(name, `team-${i}`);
                    closeAssign();
                });
                assignGrid.appendChild(b);
            }
            const poolBtn = document.createElement("button");
            poolBtn.type = "button";
            poolBtn.className = "gbtn wide";
            poolBtn.textContent = "í’€ë¡œ ì´ë™";
            poolBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                moveToPool(name);
                closeAssign();
            });
            assignGrid.appendChild(poolBtn);

            assignPortal.classList.add("open");
            assignPortal.setAttribute("aria-hidden", "false");
            requestAnimationFrame(() => placePop(assignPop, anchorEl));
        }

        assignClose.addEventListener("click", (e) => { e.stopPropagation(); closeAssign(); });
        assignBackdrop.addEventListener("click", () => closeAssign());

        /* ========= ìˆœìœ„ í™•ì • í¬íƒˆ ========= */
        const rankPortal = document.getElementById("rankPortal");
        const rankBackdrop = document.getElementById("rankBackdrop");
        const rankPop = document.getElementById("rankPop");
        const rankGrid = document.getElementById("rankGrid");
        const rankClose = document.getElementById("rankClose");
        const rankTitle = document.getElementById("rankTitle");

        let currentRankCtx = null; // {teamId, name, tieMembers, baseRank, anchorEl}

        function isRankOpen() { return rankPortal.classList.contains("open"); }
        function closeRank() {
            rankPortal.classList.remove("open");
            rankPortal.setAttribute("aria-hidden", "true");
            currentRankCtx = null;
        }

        function openRankPortal(ctx) {
            // ctx: {teamId, name, tieMembers, baseRank, anchorEl, detail}
            currentRankCtx = ctx;
            const { teamId, name, tieMembers, baseRank, anchorEl, detail } = ctx;

            const manual = ensureManual(teamId);

            rankTitle.textContent = `ìˆœìœ„ í™•ì • Â· ${name} (ë™ë¥  ${tieMembers.length}ëª…)`;
            rankGrid.innerHTML = "";

            // ìƒì„¸ ì„¤ëª… í‘œì‹œ (ëª¨ë°”ì¼ ëŒ€ì‘)
            if (detail) {
                const desc = document.createElement("div");
                desc.style.fontSize = "13px";
                desc.style.color = "#4b5563";
                desc.style.background = "#f3f4f6";
                desc.style.padding = "8px 12px";
                desc.style.borderRadius = "8px";
                desc.style.marginBottom = "12px";
                desc.style.whiteSpace = "pre-wrap"; // ì¤„ë°”ê¿ˆ ìœ ì§€
                desc.style.textAlign = "left";
                desc.textContent = detail;
                rankGrid.appendChild(desc);
            }

            const usedRanks = new Map(); // rank -> ownerName
            for (const [nm, rk] of manual.entries()) {
                if (tieMembers.includes(nm)) usedRanks.set(rk, nm);
            }

            // ê°€ëŠ¥í•œ ìˆœìœ„ ë²„íŠ¼: baseRank ... baseRank+len-1
            for (let r = baseRank; r < baseRank + tieMembers.length; r++) {
                const b = document.createElement("button");
                b.type = "button";
                b.className = "gbtn";
                b.textContent = `${r}ìœ„`;

                const owner = usedRanks.get(r);
                const alreadyMine = (manual.get(name) === r);
                if (owner && !alreadyMine) {
                    b.disabled = true;
                    b.title = `${owner}ë‹˜ì´ ì´ë¯¸ ${r}ìœ„ë¡œ í™•ì •`;
                }

                b.addEventListener("click", (e) => {
                    e.stopPropagation();

                    // ê°™ì€ ë™ë¥  ê·¸ë£¹ ë‚´ì—ì„œ ì¤‘ë³µ ë°©ì§€: ëˆ„ê°€ ê·¸ rankë¥¼ ì“°ê³  ìˆìœ¼ë©´ ì œê±°
                    for (const [nm, rk] of manual.entries()) {
                        if (nm !== name && rk === r && tieMembers.includes(nm)) {
                            manual.delete(nm);
                        }
                    }
                    manual.set(name, r);
                    renderAllTeams();
                    closeRank();
                });

                rankGrid.appendChild(b);
            }

            // í™•ì • í•´ì œ
            const clear = document.createElement("button");
            clear.type = "button";
            clear.className = "gbtn wide";
            clear.textContent = "í™•ì • í•´ì œ(ìë™ìœ¼ë¡œ ë˜ëŒë¦¬ê¸°)";
            clear.addEventListener("click", (e) => {
                e.stopPropagation();
                manual.delete(name);
                renderAllTeams();
                closeRank();
            });
            rankGrid.appendChild(clear);

            rankPortal.classList.add("open");
            rankPortal.setAttribute("aria-hidden", "false");
            requestAnimationFrame(() => placePop(rankPop, anchorEl));
        }

        rankClose.addEventListener("click", (e) => { e.stopPropagation(); closeRank(); });
        rankBackdrop.addEventListener("click", () => closeRank());

        /* ========= ì¡° ì´ë™ í¬íƒˆ (New) ========= */
        const movePortal = document.getElementById("movePortal");
        const moveBackdrop = document.getElementById("moveBackdrop");
        const movePop = document.getElementById("movePop");
        const moveGrid = document.getElementById("moveGrid");
        const moveClose = document.getElementById("moveClose");
        const moveTitle = document.getElementById("moveTitle");

        let currentMoveName = null;
        let currentMoveFromTeamId = null;
        let currentMoveAnchor = null;

        function isMoveOpen() { return movePortal.classList.contains("open"); }
        function closeMovePortal() {
            movePortal.classList.remove("open");
            movePortal.setAttribute("aria-hidden", "true");
            currentMoveName = null;
            currentMoveFromTeamId = null;
            currentMoveAnchor = null;
        }

        function cleanPlayerRecords(teamId, name) {
            if (!teamId || !name) return;
            // 1. Clean results mapping
            const resMap = ensureTeamResults(teamId);
            // key format: "A|||B"
            for (const k of resMap.keys()) {
                if (k.includes(name)) {
                    resMap.delete(k);
                }
            }
            // 2. Clean manual rank
            const manual = ensureManual(teamId);
            if (manual.has(name)) {
                manual.delete(name);
            }
        }

        function handleMovePlayer(name, fromTeamId, toTeamId) {
            if (!name || !fromTeamId) return;

            // Clean old records
            cleanPlayerRecords(fromTeamId, name);

            // Update State
            // if toTeamId is null => Pool
            if (toTeamId) {
                state.set(name, { where: "team", teamId: toTeamId });
            } else {
                state.set(name, { where: "pool" });
            }

            renderAllTeams(); // Refresh all
            closeMovePortal();
        }

        function openMoveGroupPortal(name, currentTeamId, anchorEl) {
            currentMoveName = name;
            currentMoveFromTeamId = currentTeamId;
            currentMoveAnchor = anchorEl;

            moveTitle.textContent = `ì¡° ì´ë™ Â· ${name}`;
            moveGrid.innerHTML = "";

            // Option 1: Move to Pool (Standby)
            const btnPool = document.createElement("button");
            btnPool.type = "button";
            btnPool.className = "gbtn wide";
            btnPool.textContent = "ëŒ€ê¸° ëª…ë‹¨ìœ¼ë¡œ ì´ë™";
            btnPool.style.marginBottom = "4px";
            btnPool.addEventListener("click", (e) => {
                e.stopPropagation();
                if (confirm(`'${name}' ë‹˜ì˜ ê¸°ë¡ì„ ì‚­ì œí•˜ê³  ëŒ€ê¸° ëª…ë‹¨ìœ¼ë¡œ ì´ë™í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                    handleMovePlayer(name, currentTeamId, null);
                }
            });
            moveGrid.appendChild(btnPool);

            // Option 2: Move to other groups
            if (state.groupsCount && state.groupsCount > 0) {
                for (let i = 1; i <= state.groupsCount; i++) {
                    const tid = `team-${i}`;

                    const btn = document.createElement("button");
                    btn.type = "button";
                    btn.className = "gbtn";
                    btn.textContent = `${i}ì¡°`;

                    if (tid === currentTeamId) {
                        btn.disabled = true;
                        btn.title = "í˜„ì¬ ì†Œì†ëœ ì¡°ì…ë‹ˆë‹¤.";
                        btn.textContent += " (í˜„ì¬)";
                    }

                    btn.addEventListener("click", (e) => {
                        e.stopPropagation();
                        // Auto-confirm implied by user request ("initialization is fine"), but a safe check is good.
                        // I'll skip confirm for team-move to make it snappy as per request "just click.. move".
                        // Wait, user said "initialization would be fine", implying they expect it.
                        // I will add a small confirm if there are actually scores recorded involved? 
                        // Let's just do it directly for better UX. Only confirm for "Pool" (remove from tournament) maybe? 
                        // Actually, let's just do it. Only prompt if destructive? 
                        // The user said "Init is fine".
                        handleMovePlayer(name, currentTeamId, tid);
                    });
                    moveGrid.appendChild(btn);
                }
            }

            movePortal.classList.add("open");
            movePortal.setAttribute("aria-hidden", "false");
            requestAnimationFrame(() => placePop(movePop, anchorEl));
        }

        moveClose.addEventListener("click", (e) => { e.stopPropagation(); closeMovePortal(); });
        moveBackdrop.addEventListener("click", () => closeMovePortal());

        /* ========= ì ìˆ˜ ì…ë ¥ í¬íƒˆ (New) ========= */
        const scorePortal = document.getElementById("scorePortal");
        const scoreBackdrop = document.getElementById("scoreBackdrop");
        const scorePop = document.getElementById("scorePop");
        const scoreGrid = document.getElementById("scoreGrid");
        const scoreClose = document.getElementById("scoreClose");
        const scoreTitle = document.getElementById("scoreTitle");

        let currentScoreCtx = null; // {teamId, rowPlayer, colPlayer, anchorEl}

        function isScoreOpen() { return scorePortal.classList.contains("open"); }
        function closeScorePortal() {
            scorePortal.classList.remove("open");
            scorePortal.setAttribute("aria-hidden", "true");
            currentScoreCtx = null;
        }

        function openScorePortal(ctx) {
            currentScoreCtx = ctx;
            const { teamId, rowPlayer, colPlayer, anchorEl } = ctx;
            const resMap = ensureTeamResults(teamId);
            const k = keyPair(rowPlayer, colPlayer);
            const currentVal = resMap.get(k)?.score || "";

            // Title: A vs B
            scoreTitle.textContent = `${rowPlayer} vs ${colPlayer}`;
            scoreGrid.innerHTML = "";

            // Generate Options based on Match Format
            const format = matchFormatEl.value; // bo3 or bo5
            const optionValues = SCORE_OPTIONS[format] || [];

            // Filter out empty string if present in options (we handle Clear separately)
            const validOptions = optionValues.filter(v => v !== "");

            validOptions.forEach(val => {
                const parsed = parseScore(val);
                if (!parsed) return;

                const b = document.createElement("button");
                b.type = "button";
                b.className = "gbtn";

                // Label Logic: Row Perspective
                // val is "Left-Right". 
                // We need to determine if "Left" corresponds to RowPlayer or ColPlayer.
                // However, the SCORE_OPTIONS are just generic strings "2-0", "2-1".
                // We typically interpret them as "Winner-Loser" or "Left-Right".
                // Wait, SCORE_OPTIONS are e.g. ["2-0", "2-1", "1-2", "0-2"].
                // Let's assume the standard: Left is Row, Right is Col?
                // Actually, my plan said:
                // If Left > Right: " (ìŠ¹)"
                // If Left < Right: " (íŒ¨)"

                const left = parsed.a; // rowPlayer score
                const right = parsed.b; // colPlayer score

                let label = "";
                if (left > right) {
                    // Row Player Wins
                    label = `${rowPlayer} ìŠ¹ (${left}-${right})`;
                    b.classList.add("win-btn");
                    b.classList.remove("lose-btn");
                    b.style.color = "#1d4ed8";
                } else {
                    // Row Player Loses
                    label = `${rowPlayer} íŒ¨ (${left}-${right})`;
                    b.classList.add("lose-btn");
                    b.classList.remove("win-btn");
                    b.style.color = "#ef4444";
                }

                b.style.fontWeight = "bold";

                b.textContent = label;

                // Highlight current selection
                // We need to match the stored score. 
                // Stored score direction might be Row-Col or Col-Row depending on alphabetical order.
                // We need to normalize 'val' to the stored key direction to check equality?
                // Actually, simplest is: if I click this button "2-1", it means Row gets 2, Col gets 1.
                // So I will construct the stored string based on KeyPair.

                b.addEventListener("click", (e) => {
                    e.stopPropagation();

                    // Logic: Row=Left(val.a), Col=Right(val.b)
                    const rowIsFirst = k.startsWith(`${rowPlayer}|||`);

                    // if rowIsFirst, we want store = "Left-Right"
                    // if !rowIsFirst (Col is first), we want store = "Right-Left"
                    let storeVal = "";
                    if (rowIsFirst) {
                        storeVal = `${left}-${right}`;
                    } else {
                        storeVal = `${right}-${left}`;
                    }

                    resMap.set(k, { score: storeVal });
                    renderAllTeams();
                    closeScorePortal();
                });

                scoreGrid.appendChild(b);
            });

            // Clear Button
            const btnClear = document.createElement("button");
            btnClear.type = "button";
            btnClear.className = "gbtn wide";
            btnClear.textContent = "ì ìˆ˜ ì‚­ì œ";
            btnClear.style.color = "#ef4444";
            btnClear.addEventListener("click", (e) => {
                e.stopPropagation();
                resMap.delete(k);
                renderAllTeams();
                closeScorePortal();
            });
            scoreGrid.appendChild(btnClear);

            scorePortal.classList.add("open");
            scorePortal.setAttribute("aria-hidden", "false");
            requestAnimationFrame(() => placePop(scorePop, anchorEl));
        }

        scoreClose.addEventListener("click", (e) => { e.stopPropagation(); closeScorePortal(); });
        scoreBackdrop.addEventListener("click", () => closeScorePortal());

        /* ========= ë„ì›€ë§ í¬íƒˆ ========= */
        const helpPortal = document.getElementById("helpPortal");
        const helpBackdrop = document.getElementById("helpBackdrop");
        const helpPop = document.getElementById("helpPop");
        const helpClose = document.getElementById("helpClose");
        const openHelpBtn = document.getElementById("openHelpBtn");

        function isHelpOpen() { return helpPortal.classList.contains("open"); }
        function closeHelp() {
            helpPortal.classList.remove("open");
            helpPortal.setAttribute("aria-hidden", "true");
        }
        function openHelp() {
            helpPortal.classList.add("open");
            helpPortal.setAttribute("aria-hidden", "false");
            const w = window.innerWidth;
            const h = window.innerHeight;
            const pw = helpPop.offsetWidth || 300;
            const ph = helpPop.offsetHeight || 400;
            helpPop.style.left = Math.max(0, (w - pw) / 2) + "px";
            helpPop.style.top = Math.max(0, (h - ph) / 2) + "px";
            helpPop.style.visibility = "visible";
        }

        helpClose.addEventListener("click", (e) => { e.stopPropagation(); closeHelp(); });
        helpBackdrop.addEventListener("click", () => closeHelp());
        openHelpBtn.addEventListener("click", () => openHelp());

        // ESCë¡œ ë‹«ê¸°
        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
                closeAssign();
                closeRank();
                closeMovePortal(); // Added
                closeScorePortal(); // Added
            }
        });

        // ë¦¬ì‚¬ì´ì¦ˆ/ìŠ¤í¬ë¡¤ ì‹œ í¬íƒˆ ìœ„ì¹˜ ë³´ì •
        window.addEventListener("resize", () => {
            if (isAssignOpen() && currentAssignAnchor) placePop(assignPop, currentAssignAnchor);
            if (isRankOpen() && currentRankCtx?.anchorEl) placePop(rankPop, currentRankCtx.anchorEl);
            if (isMoveOpen() && currentMoveAnchor) placePop(movePop, currentMoveAnchor);
            if (isScoreOpen() && currentScoreCtx?.anchorEl) placePop(scorePop, currentScoreCtx.anchorEl);
        }, { passive: true });
        window.addEventListener("scroll", () => {
            if (isAssignOpen() && currentAssignAnchor) placePop(assignPop, currentAssignAnchor);
            if (isRankOpen() && currentRankCtx?.anchorEl) placePop(rankPop, currentRankCtx.anchorEl);
            if (isMoveOpen() && currentMoveAnchor) placePop(movePop, currentMoveAnchor);
            if (isScoreOpen() && currentScoreCtx?.anchorEl) placePop(scorePop, currentScoreCtx.anchorEl);
        }, { passive: true, capture: true });

        /* ========= Drag & Drop ========= */
        function makeDropTarget(el, onDrop) {
            const onOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = "move";
                el.classList.add("dragover");
            };
            const onLeave = () => el.classList.remove("dragover");

            el.addEventListener("dragenter", onOver);
            el.addEventListener("dragover", onOver);
            el.addEventListener("dragleave", onLeave);

            el.addEventListener("drop", (e) => {
                e.preventDefault();
                el.classList.remove("dragover");
                const name = e.dataTransfer.getData("text/plain");
                if (!name) return;
                onDrop(name, e);
            });
        }

        // CSS for score-cell added dynamically or we can just rely on inline. 
        // Let's rely on inline for now as it's simple.

        function initState() {
            state.clear();
            for (const n of INITIAL_NAMES) state.set(n, { where: "pool" });
            resultsByTeam.clear();
            manualRankByTeam.clear();
            state.groupsCount = 0;
            closeAssign();
            closeRank();
        }

        function ensureTeamResults(teamId) {
            if (!resultsByTeam.has(teamId)) resultsByTeam.set(teamId, new Map());
            return resultsByTeam.get(teamId);
        }

        function keyPair(a, b) {
            return (a.localeCompare(b, 'ko') <= 0) ? `${a}|||${b}` : `${b}|||${a}`;
        }

        function parseScore(score) {
            if (!score) return null;
            const m = score.split("-");
            if (m.length !== 2) return null;
            const a = Number(m[0]), b = Number(m[1]);
            if (!Number.isFinite(a) || !Number.isFinite(b)) return null;
            return { a, b };
        }

        function getTeamMembers(teamId) {
            const members = [];
            for (const name of INITIAL_NAMES) {
                const s = state.get(name);
                if (s?.where === "team" && s.teamId === teamId) members.push(name);
            }
            return members;
        }

        function createNameChip(name) {
            const div = document.createElement("div");
            div.className = "name-chip";
            div.draggable = true;
            div.dataset.name = name;
            // íŒíŠ¸: í´ë¦­ ê°€ëŠ¥í•¨ì„ ë³´ì—¬ì£¼ê¸° ìœ„í•´ title ì†ì„± ì¶”ê°€
            div.title = "í´ë¦­í•˜ì—¬ ì¡° ì„ íƒ / ë“œë˜ê·¸í•˜ì—¬ ì´ë™";

            const nm = document.createElement("span");
            nm.className = "nm";
            nm.textContent = name;

            // âœ… ì „ì²´ ì˜ì—­ í´ë¦­ ì‹œ ì¡° ì„ íƒ
            div.addEventListener("click", (e) => {
                e.stopPropagation();
                if (div.classList.contains("dragging")) return; // ë“œë˜ê·¸ ì§í›„ í´ë¦­ ë°©ì§€(ë³´í†µ ë¸Œë¼ìš°ì €ê°€ ë§‰ì•„ì£¼ì§€ë§Œ ì•ˆì „í•˜ê²Œ)

                if (isAssignOpen() && currentAssignName === name && currentAssignAnchor === div) {
                    closeAssign(); return;
                }
                closeRank();
                openAssign(div, name);
            });

            div.append(nm);

            div.addEventListener("dragstart", (e) => {
                closeAssign(); closeRank();
                e.dataTransfer.setData("text/plain", name);
                e.dataTransfer.effectAllowed = "move";
                div.classList.add("dragging");
            });
            div.addEventListener("dragend", () => div.classList.remove("dragging"));

            return div;
        }

        function renderPool() {
            poolEl.innerHTML = "";
            const inPool = [];
            for (const name of INITIAL_NAMES) {
                const s = state.get(name);
                if (s?.where === "pool") inPool.push(name);
            }
            inPool.forEach(n => poolEl.appendChild(createNameChip(n)));
            setText(poolCountEl, `${inPool.length}ëª…`);
        }

        function hasAnyPlayedMatch(teamId, players) {
            if (players.length < 2) return false;
            const resMap = ensureTeamResults(teamId);
            for (let i = 0; i < players.length; i++) {
                for (let j = i + 1; j < players.length; j++) {
                    const k = keyPair(players[i], players[j]);
                    const parsed = parseScore(resMap.get(k)?.score || "");
                    if (parsed) return true;
                }
            }
            return false;
        }

        /* ========= ìë™ ìˆœìœ„ ê³„ì‚° (ê³µë™ ìˆœìœ„ í¬í•¨) =========
           ê·œì¹™:
           1) ìŠ¹(ìŠ¹ì ) ë‚´ë¦¼ì°¨ìˆœ
           (ë™ë¥  ê·¸ë£¹)
           2) 2ëª… ë™ë¥ ì´ë©´: ë§ëŒ€ê²°(H2H) ê°€ëŠ¥í•˜ë©´ ì ìš©
           3) ë™ë¥ ê·¸ë£¹ ì„¸íŠ¸ë“ì‹¤(SD)
           4) ë™ë¥ ê·¸ë£¹ ì„¸íŠ¸ë“(SF)
           5) ê·¸ë˜ë„ ì™„ì „ ë™ë¥ ì´ë©´: ê³µë™(TIE)ë¡œ ë¬¶ìŒ (ê°€ë‚˜ë‹¤ëŠ” "í‘œì‹œ ìˆœì„œ"ë§Œ)
        */
        function computeRanking(teamId, players) {
            const resMap = ensureTeamResults(teamId);

            // ê¸°ë³¸ í†µê³„
            const base = new Map();
            players.forEach(p => base.set(p, { name: p, played: 0, win: 0, lose: 0, setsFor: 0, setsAgainst: 0 }));

            for (let i = 0; i < players.length; i++) {
                for (let j = i + 1; j < players.length; j++) {
                    const A = players[i], B = players[j];
                    const k = keyPair(A, B);
                    const parsed = parseScore(resMap.get(k)?.score || "");
                    if (!parsed) continue;

                    const aIsFirst = k.startsWith(`${A}|||`);
                    const aScore = aIsFirst ? parsed.a : parsed.b;
                    const bScore = aIsFirst ? parsed.b : parsed.a;

                    const sA = base.get(A), sB = base.get(B);
                    sA.played++; sB.played++;
                    sA.setsFor += aScore; sA.setsAgainst += bScore;
                    sB.setsFor += bScore; sB.setsAgainst += aScore;

                    if (aScore > bScore) { sA.win++; sB.lose++; }
                    else if (aScore < bScore) { sB.win++; sA.lose++; }
                }
            }

            const anyPlayed = Array.from(base.values()).some(s => s.played > 0);
            const statsArr = Array.from(base.values()).map(s => ({ ...s, points: s.win }));

            // ì ìˆ˜ ì…ë ¥ ì „ì´ë©´ rankëŠ” null
            if (!anyPlayed) {
                const out = new Map();
                players.forEach(p => {
                    const s = base.get(p);
                    out.set(p, {
                        ...s,
                        points: s.win,
                        autoRank: null,
                        autoReason: null,
                        tieKey: null,
                        tieMembers: null,
                        tieBaseRank: null
                    });
                });
                return { map: out, anyPlayed, tieGroups: [] };
            }

            function headToHeadWinner(a, b) {
                const k = keyPair(a, b);
                const parsed = parseScore(resMap.get(k)?.score || "");
                if (!parsed) return null;
                const aIsFirst = k.startsWith(`${a}|||`);
                const aScore = aIsFirst ? parsed.a : parsed.b;
                const bScore = aIsFirst ? parsed.b : parsed.a;
                if (aScore === bScore) return null;
                return aScore > bScore ? a : b;
            }

            function innerStats(group) {
                const inner = new Map();
                group.forEach(p => inner.set(p, { diff: 0, for: 0 }));
                for (let i = 0; i < group.length; i++) {
                    for (let j = i + 1; j < group.length; j++) {
                        const A = group[i], B = group[j];
                        const k = keyPair(A, B);
                        const parsed = parseScore(resMap.get(k)?.score || "");
                        if (!parsed) continue;
                        const aIsFirst = k.startsWith(`${A}|||`);
                        const aScore = aIsFirst ? parsed.a : parsed.b;
                        const bScore = aIsFirst ? parsed.b : parsed.a;
                        inner.get(A).diff += (aScore - bScore);
                        inner.get(B).diff += (bScore - aScore);
                        inner.get(A).for += aScore;
                        inner.get(B).for += bScore;
                    }
                }
                return inner;
            }

            // ìŠ¹ì ìœ¼ë¡œ 1ì°¨ ê·¸ë£¹
            statsArr.sort((x, y) => (y.points - x.points) || x.name.localeCompare(y.name, 'ko'));

            const blocks = []; // [{members:[...], reasonForLeader:'H2H/SD/SF/TIE/...' } ...] but we keep reason per member later
            const tieGroups = []; // [{tieKey, members, baseRank}]
            const reasonMap = new Map(); // name -> code (H2H/SD/SF/TIE)
            const detailMap = new Map(); // name -> specific explanation string

            // Initialize detail with basic stats
            statsArr.forEach(s => {
                const diff = s.setsFor - s.setsAgainst;
                const sign = diff >= 0 ? "+" : "";
                detailMap.set(s.name, `${s.win}ìŠ¹ ${s.lose}íŒ¨ (ë“ì‹¤ ${sign}${diff})`);
            });

            let i = 0;

            while (i < statsArr.length) {
                const pts = statsArr[i].points;
                const group = [];
                while (i < statsArr.length && statsArr[i].points === pts) {
                    group.push(statsArr[i].name);
                    i++;
                }

                if (group.length === 1) {
                    blocks.push({ members: [group[0]], type: "single" });
                    continue;
                }

                // ë™ë¥  ë°œìƒ ì‹œ, ê¸°ë³¸ í…ìŠ¤íŠ¸ì— "ë™ë¥ " ì •ë³´ ì¶”ê°€
                group.forEach(nm => {
                    const prev = detailMap.get(nm);
                    detailMap.set(nm, prev + `\nâ”” ${group.length}ëª… ë™ë¥ (${pts}ìŠ¹)`);
                });

                // 2ëª… ë™ë¥ : H2H ìš°ì„ 
                if (group.length === 2) {
                    const [a, b] = group;
                    const w = headToHeadWinner(a, b);
                    if (w) {
                        const winner = w;
                        const loser = (w === a) ? b : a;

                        reasonMap.set(winner, "H2H");
                        detailMap.set(winner, detailMap.get(winner) + `\nâ”” ìŠ¹ììŠ¹ ìš°ì„¸ (vs ${loser})`);
                        detailMap.set(loser, detailMap.get(loser) + `\nâ”” ìŠ¹ììŠ¹ ì—´ì„¸ (vs ${winner})`);

                        blocks.push({ members: [winner], type: "single" });
                        blocks.push({ members: [loser], type: "single" });
                    } else {
                        // H2Hê°€ ì—†ìœ¼ë©´ ì „ì²´ ë“ì‹¤(SD)/ë“ì (SF) ì‚¬ìš©
                        const sA = base.get(a), sB = base.get(b);
                        const da = sA.setsFor - sA.setsAgainst;
                        const db = sB.setsFor - sB.setsAgainst;
                        const fa = sA.setsFor, fb = sB.setsFor;

                        if (da !== db) {
                            const better = (da > db) ? a : b;
                            const worse = (da > db) ? b : a;
                            const dBet = (da > db) ? da : db;
                            const dWor = (da > db) ? db : da;

                            reasonMap.set(better, "SD");
                            detailMap.set(better, detailMap.get(better) + `\nâ”” ë“ì‹¤ ìš°ì„¸ (${dBet} vs ${dWor})`);
                            detailMap.set(worse, detailMap.get(worse) + `\nâ”” ë“ì‹¤ ì—´ì„¸ (${dWor} vs ${dBet})`);

                            blocks.push({ members: [better], type: "single" });
                            blocks.push({ members: [worse], type: "single" });
                        } else if (fa !== fb) {
                            const better = (fa > fb) ? a : b;
                            const worse = (fa > fb) ? b : a;

                            reasonMap.set(better, "SF");
                            detailMap.set(better, detailMap.get(better) + `\nâ”” ë‹¤ë“ì  ìš°ì„¸ (${(fa > fb) ? fa : fb} vs ${(fa > fb) ? fb : fa})`);
                            detailMap.set(worse, detailMap.get(worse) + `\nâ”” ë‹¤ë“ì  ì—´ì„¸`);

                            blocks.push({ members: [better], type: "single" });
                            blocks.push({ members: [worse], type: "single" });
                        } else {
                            // ì™„ì „ ë™ë¥ : ê³µë™
                            const ordered = [...group].sort((x, y) => x.localeCompare(y, 'ko'));
                            ordered.forEach(n => {
                                reasonMap.set(n, "TIE");
                                detailMap.set(n, detailMap.get(n) + `\nâ”” ì™„ì „ ë™ë¥  (ê³µë™ ìˆœìœ„)`);
                            });
                            blocks.push({ members: ordered, type: "tie" });
                        }
                    }
                    continue;
                }

                // 3ëª… ì´ìƒ ë™ë¥ : ì „ì²´ SD/SFë¡œ ì •ë ¬
                const ordered = [...group].sort((a, b) => {
                    const sA = base.get(a), sB = base.get(b);
                    const da = sA.setsFor - sA.setsAgainst;
                    const db = sB.setsFor - sB.setsAgainst;
                    if (db !== da) return db - da; // Desc

                    const fa = sA.setsFor, fb = sB.setsFor;
                    if (fb !== fa) return fb - fa; // Desc

                    return a.localeCompare(b, 'ko'); // Asc
                });

                // diff/for ë™ì¼í•œ êµ¬ê°„ì„ tie-blockìœ¼ë¡œ ë¬¶ê¸°
                let k = 0;
                while (k < ordered.length) {
                    const head = ordered[k];
                    const sHead = base.get(head);
                    const headDiff = sHead.setsFor - sHead.setsAgainst;
                    const headFor = sHead.setsFor;

                    const chunk = [head];
                    k++;
                    while (k < ordered.length) {
                        const cur = ordered[k];
                        const sCur = base.get(cur);
                        const curDiff = sCur.setsFor - sCur.setsAgainst;
                        const curFor = sCur.setsFor;

                        if (curDiff === headDiff && curFor === headFor) {
                            chunk.push(cur);
                            k++;
                        } else break;
                    }

                    if (chunk.length === 1) {
                        const better = chunk[0];
                        if (!reasonMap.has(better)) {
                            reasonMap.set(better, "SD");
                            detailMap.set(better, detailMap.get(better) + `\nâ”” 3ìê°„ ë“ì‹¤/ë‹¤ë“ì  ìš°ìœ„`);
                        }
                        blocks.push({ members: chunk, type: "single" });
                    } else if (chunk.length === 2) {
                        // 2ëª…ë§Œ ë‚¨ì€ ë™ë¥  chunkë¼ë©´ H2H í•œ ë²ˆ ë” ì‹œë„
                        const [a, b] = chunk;
                        const w = headToHeadWinner(a, b);
                        if (w) {
                            const winner = w;
                            const loser = (w === a) ? b : a;
                            reasonMap.set(winner, "H2H");
                            detailMap.set(winner, detailMap.get(winner) + `\nâ”” (ì¬)ìŠ¹ììŠ¹ ìš°ì„¸`);
                            detailMap.set(loser, detailMap.get(loser) + `\nâ”” (ì¬)ìŠ¹ììŠ¹ ì—´ì„¸`);

                            blocks.push({ members: [winner], type: "single" });
                            blocks.push({ members: [loser], type: "single" });
                        } else {
                            const ord2 = [...chunk].sort((x, y) => x.localeCompare(y, 'ko'));
                            ord2.forEach(n => {
                                reasonMap.set(n, "TIE");
                                detailMap.set(n, detailMap.get(n) + `\nâ”” (ì¬)ì™„ì „ ë™ë¥ `);
                            });
                            blocks.push({ members: ord2, type: "tie" });
                        }
                    } else {
                        // 3ëª… ì´ìƒ ì™„ì „ ë™ë¥ : ê³µë™
                        const ordN = [...chunk].sort((x, y) => x.localeCompare(y, 'ko'));
                        ordN.forEach(n => {
                            reasonMap.set(n, "TIE");
                            detailMap.set(n, detailMap.get(n) + `\nâ”” (3ìì´ìƒ)ì™„ì „ ë™ë¥ `);
                        });
                        blocks.push({ members: ordN, type: "tie" });
                    }
                }
            }

            // blocks -> rank ë¶€ì—¬(competition ranking)
            const out = new Map();
            let rank = 1;

            for (const b of blocks) {
                if (b.members.length === 1) {
                    const nm = b.members[0];
                    const s = base.get(nm);
                    out.set(nm, {
                        ...s,
                        points: s.win,
                        autoRank: rank,
                        autoReason: reasonMap.get(nm) || null,
                        autoDetail: detailMap.get(nm) || "", // ìƒì„¸ ì„¤ëª… ì¶”ê°€
                        tieKey: null,
                        tieMembers: null,
                        tieBaseRank: null
                    });
                    rank += 1;
                } else {
                    // tie block
                    const baseRank = rank;
                    const members = b.members;
                    const tieKey = `${teamId}|pts=${base.get(members[0]).win}|r=${baseRank}|d?`; // ìœ ë‹ˆí¬ë§Œ ë˜ë©´ OK
                    tieGroups.push({ tieKey, members, baseRank });

                    for (const nm of members) {
                        const s = base.get(nm);
                        out.set(nm, {
                            ...s,
                            points: s.win,
                            autoRank: baseRank,        // ê³µë™ í‘œì‹œì˜ ê¸°ì¤€ rank
                            autoReason: "TIE",
                            autoDetail: detailMap.get(nm) || "", // ìƒì„¸ ì„¤ëª… ì¶”ê°€
                            tieKey,
                            tieMembers: members,
                            tieBaseRank: baseRank
                        });
                    }
                    rank += members.length;
                }
            }

            return { map: out, anyPlayed, tieGroups };
        }

        // âœ… manualRankë¥¼ ë°˜ì˜í•œ "ìµœì¢… í‘œì‹œ"
        function resolveFinalRanks(teamId, autoPack) {
            const manual = ensureManual(teamId);
            const final = new Map(); // name -> {finalRank, finalLabel, isManual, isTieClickable, tieMembers, baseRank}
            const anyPlayed = autoPack.anyPlayed;

            // ì ìˆ˜ ì…ë ¥ ì „ì´ë©´ ê·¸ëƒ¥ ë¹ˆì¹¸
            if (!anyPlayed) {
                for (const [nm, st] of autoPack.map.entries()) {
                    final.set(nm, {
                        finalRank: null,
                        finalLabel: "",
                        isManual: false,
                        isTieClickable: false,
                        tieMembers: null,
                        baseRank: null,
                        detail: ""
                    });
                }
                return final;
            }

            // tie groupë³„ë¡œ "ì „ì› ìˆ˜ë™ í™•ì •ëëŠ”ì§€" í™•ì¸
            const tieInfoByKey = new Map(); // tieKey -> {members, baseRank, allAssigned:boolean}
            for (const tg of autoPack.tieGroups) {
                const assignedCount = tg.members.filter(nm => manual.has(nm)).length;
                tieInfoByKey.set(tg.tieKey, {
                    members: tg.members,
                    baseRank: tg.baseRank,
                    allAssigned: (assignedCount === tg.members.length)
                });
            }

            for (const [nm, st] of autoPack.map.entries()) {
                // ë™ë¥  ê·¸ë£¹ì´ë©´ í´ë¦­ ê°€ëŠ¥
                const isTie = !!st.tieKey;
                const ti = isTie ? tieInfoByKey.get(st.tieKey) : null;

                if (isTie) {
                    // ìˆ˜ë™ í™•ì •ì´ ìˆìœ¼ë©´ ê·¸ ê°’ ì‚¬ìš©(ë¶€ë¶„ í™•ì •ë„ í‘œì‹œ ê°€ëŠ¥)
                    if (manual.has(nm)) {
                        const r = manual.get(nm);
                        final.set(nm, {
                            finalRank: r,
                            finalLabel: `${r}ìœ„`,
                            isManual: true,
                            isTieClickable: true,
                            tieMembers: ti.members,
                            baseRank: ti.baseRank,
                            detail: st.autoDetail
                        });
                    } else {
                        // ì „ì› í™•ì •ì´ë©´, ë‚¨ì€ ì‚¬ëŒì€ ì—†ê²Œ ë˜ëŠ” ê²Œ ì •ìƒ(ìš´ì˜ìƒ). ê·¸ë˜ë„ ì•ˆì „í•˜ê²Œ ê³µë™ í‘œì‹œ ìœ ì§€.
                        const label = `ê³µë™ ${st.autoRank}ìœ„`;
                        final.set(nm, {
                            finalRank: ti.allAssigned ? st.autoRank : st.autoRank,
                            finalLabel: label,
                            isManual: false,
                            isTieClickable: true,
                            tieMembers: ti.members,
                            baseRank: ti.baseRank,
                            detail: st.autoDetail
                        });
                    }
                } else {
                    // ì¼ë°˜ ì¼€ì´ìŠ¤
                    const r = st.autoRank;
                    final.set(nm, {
                        finalRank: r,
                        finalLabel: (r ? `${r}ìœ„` : ""),
                        isManual: false,
                        isTieClickable: false,
                        tieMembers: null,
                        baseRank: null,
                        detail: st.autoDetail
                    });
                }
            }

            return final;
        }

        /* ========= ë Œë” ========= */
        function renderRoundRobin(teamBox, teamId, players) {
            const host = teamBox.querySelector(".rr-host");
            host.innerHTML = "";

            const wrap = document.createElement("div");
            wrap.className = "rr-wrap";

            const ttl = document.createElement("div");
            ttl.className = "rr-title";
            ttl.innerHTML = `<div class="ttl"></div>
                       <div class="sub"></div>`;
            wrap.appendChild(ttl);

            if (players.length === 0) {
                const empty = document.createElement("div");
                empty.style.color = "var(--muted)";
                empty.style.fontSize = "12px";
                empty.style.fontWeight = "800";
                empty.style.padding = "10px 2px 2px";
                empty.textContent = "ì„ ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤. ì´ë¦„ì„ ë“œë¡­í•˜ê±°ë‚˜ â€˜ì„ íƒâ€™ìœ¼ë¡œ í¸ì„±í•˜ì„¸ìš”.";
                wrap.appendChild(empty);
                host.appendChild(wrap);
                return;
            }

            const resMap = ensureTeamResults(teamId);
            const options = SCORE_OPTIONS[matchFormatEl.value];

            const autoPack = computeRanking(teamId, players);
            const finalPack = resolveFinalRanks(teamId, autoPack);
            const anyPlayed = autoPack.anyPlayed;

            const scroll = document.createElement("div");
            scroll.className = "table-scroll";

            const tbl = document.createElement("table");
            tbl.className = "rr";
            // Rank column is 1.5x width from CSS, so we add 0.5 to total count
            tbl.style.setProperty("--cols", String(players.length + 4.5));

            const thead = document.createElement("thead");
            const hr = document.createElement("tr");

            const corner = document.createElement("th");
            corner.className = "corner sticky";
            corner.textContent = "ì„ ìˆ˜";
            hr.appendChild(corner);

            players.forEach(p => {
                const th = document.createElement("th");
                th.className = "sticky clickable-head";
                th.textContent = p;
                th.title = "í´ë¦­í•˜ì—¬ ì¡° ì´ë™";
                th.onclick = (e) => {
                    e.stopPropagation();
                    openMoveGroupPortal(p, teamId, th);
                };
                hr.appendChild(th);
            });

            const wlTh = document.createElement("th");
            wlTh.className = "sticky";
            wlTh.textContent = "ìŠ¹-íŒ¨";
            hr.appendChild(wlTh);

            const ptTh = document.createElement("th");
            ptTh.className = "sticky";
            ptTh.textContent = "ë“ì‹¤";
            hr.appendChild(ptTh);

            const rkTh = document.createElement("th");
            rkTh.className = "sticky rank";
            rkTh.textContent = "ìˆœìœ„";
            hr.appendChild(rkTh);

            thead.appendChild(hr);
            tbl.appendChild(thead);

            const tbody = document.createElement("tbody");

            // âœ… 1ë“± í¬ë¼ìš´: "ìµœì¢… rank=1"ì¸ ì‚¬ëŒì´ ë‹¨ë…ìœ¼ë¡œ ìˆì„ ë•Œë§Œ
            let crownOwner = null;
            if (anyPlayed) {
                const r1 = [];
                for (const p of players) {
                    const f = finalPack.get(p);
                    if (f?.finalRank === 1 && f.finalLabel === "1ìœ„") r1.push(p);
                }
                if (r1.length === 1) crownOwner = r1[0];
            }

            for (let i = 0; i < players.length; i++) {
                const rowP = players[i];
                const tr = document.createElement("tr");

                const left = document.createElement("th");
                left.className = "leftsticky clickable-head";
                left.textContent = rowP;
                left.title = "í´ë¦­í•˜ì—¬ ì¡° ì´ë™";
                left.onclick = (e) => {
                    e.stopPropagation();
                    openMoveGroupPortal(rowP, teamId, left);
                };
                tr.appendChild(left);

                for (let j = 0; j < players.length; j++) {
                    const colP = players[j];
                    const td = document.createElement("td");

                    // âœ… i!=jëŠ” ì „ë¶€ ì…ë ¥ ê°€ëŠ¥(select)
                    if (i === j) {
                        td.className = "diag";
                        td.textContent = "â€”";
                    } else {
                        // âœ… View Mode + Click to Open Portal
                        const k = keyPair(rowP, colP);

                        const cell = document.createElement("div");
                        cell.className = "score-cell";
                        // We might need CSS for .score-cell to look like a button or clickable area
                        // Using inline styles for now or reuse existing class if possible.
                        // Let's add a class 'score-trigger' and style it.
                        cell.style.cursor = "pointer";
                        cell.style.padding = "4px";
                        cell.style.borderRadius = "6px";
                        cell.style.textAlign = "center";
                        cell.style.fontWeight = "bold";
                        cell.title = "í´ë¦­í•˜ì—¬ ì ìˆ˜ ì…ë ¥";

                        // Hover effect
                        cell.onmouseover = () => cell.style.backgroundColor = "#f1f5f9";
                        cell.onmouseout = () => cell.style.backgroundColor = "transparent";

                        const current = resMap.get(k)?.score || "";
                        let displayTxt = "-";
                        let color = "var(--muted)";

                        if (current) {
                            const parsed = parseScore(current);
                            if (parsed) {
                                const rowIsFirst = k.startsWith(`${rowP}|||`);
                                const myScore = rowIsFirst ? parsed.a : parsed.b;
                                const opScore = rowIsFirst ? parsed.b : parsed.a;

                                displayTxt = String(myScore);

                                // Color / Style based on Win/Loss
                                if (myScore > opScore) {
                                    color = "#1d4ed8"; // Win Blue
                                } else {
                                    color = "#ef4444"; // Lose Red? Or Gray? 
                                    // Usually formatting: Win=Blue, Lose=Red or Muted.
                                    color = "#ef4444";
                                }
                            }
                        }

                        cell.textContent = displayTxt;
                        cell.style.color = color;
                        if (displayTxt !== "-") cell.style.fontSize = "15px";

                        cell.addEventListener("click", (e) => {
                            e.stopPropagation();
                            closeAssign();
                            closeRank();
                            closeMovePortal();
                            openScorePortal({
                                teamId,
                                rowPlayer: rowP,
                                colPlayer: colP,
                                anchorEl: cell
                            });
                        });

                        td.appendChild(cell);
                    }

                    tr.appendChild(td);
                }

                // ìŠ¹-íŒ¨
                const st = autoPack.map.get(rowP);
                const wl = document.createElement("td");
                wl.className = "wl";
                wl.textContent = st ? `${st.win}-${st.lose}` : "0-0";
                tr.appendChild(wl);

                // ë“ì‹¤ (SD)
                const pt = document.createElement("td");
                pt.className = "wl";
                if (st) {
                    const diff = st.setsFor - st.setsAgainst;
                    const sign = diff > 0 ? "+" : "";
                    pt.textContent = `${sign}${diff}`;

                    if (diff > 0) {
                        pt.style.color = "#1d4ed8"; // Blue
                        pt.style.fontWeight = "900";
                    } else if (diff < 0) {
                        pt.style.color = "#9ca3af"; // Gray
                        pt.style.fontWeight = "400";
                    } else {
                        pt.style.color = "#6b7280"; // Muted
                        pt.style.fontWeight = "400";
                    }
                } else {
                    pt.textContent = "-";
                    pt.style.color = "var(--muted)";
                }
                tr.appendChild(pt);

                // ìˆœìœ„
                const rk = document.createElement("td");
                rk.className = "rank";

                if (!anyPlayed) {
                    rk.textContent = "";
                } else {
                    const f = finalPack.get(rowP);
                    const auto = autoPack.map.get(rowP);

                    // í‘œì‹œ ë¼ë²¨
                    let label = f?.finalLabel || "";
                    let code = "";

                    // ê³µë™ í‘œì‹œë©´ TIE ë¶™ì„
                    if (auto?.autoReason === "TIE" && !f?.isManual) {
                        code = "TIE";
                    } else if (auto?.autoReason && auto.autoReason !== "TIE") {
                        // H2H/SD/SFëŠ” ë‹¨ë…ì¼ ë•Œë§Œ ì˜ë¯¸ìˆê²Œ
                        code = auto.autoReason;
                    }

                    // í¬ë¼ìš´
                    const crown = (crownOwner === rowP) ? `<span class="crown">ğŸ‘‘</span>` : "";

                    // manual ë±ƒì§€
                    const man = f?.isManual ? `<span class="manual" title="ì‚¬ìš©ì í™•ì •">MAN</span>` : "";

                    // code ë±ƒì§€
                    // code ë±ƒì§€ (íƒ€ì´ë¸Œë ˆì´ì»¤ íˆ´íŒ ì œê±°)
                    const codeTag = code ? `<span class="code"${code === 'TIE' ? ' title="ë™ë¥ ì´ ëê¹Œì§€ ì•ˆ í’€ë ¤ ê³µë™ ìˆœìœ„"' : ''}>${code}</span>` : "";

                    rk.innerHTML = `${crown}${label}${codeTag}${man}`;

                    // âœ… ë­í‚¹ ìƒì„¸ ì„¤ëª… íˆ´íŒ
                    if (f?.detail) {
                        rk.title = f.detail;
                        rk.style.cursor = "help"; // ë„ì›€ì´ ëœë‹¤ëŠ” ì»¤ì„œ í‘œì‹œ
                    }

                    // âœ… ë­í‚¹ ìƒì„¸ ì„¤ëª… íˆ´íŒ (ì‚¬ìš©ì ìš”ì²­: íƒ€ì´ë¸Œë ˆì´ì»¤/ë‹¨ë… ë“±ì€ íŒì—… ì œì™¸, ì™„ì „ ë™ë¥ ë§Œ í‘œì‹œ)
                    // "íƒ€ì´ë¸Œë ˆì´ì»¤ë¡œ ê²°ì •ì€ íŒì—…ì„ ì•ˆë„ì›Œë„ ë ê±° ê°™ì• "
                    if (f?.detail && auto?.autoReason === "TIE") {
                        rk.title = f.detail;
                        rk.style.cursor = "help";
                    }

                    // âœ… ë™ë¥ (TIE)ì´ë©´ í´ë¦­í•´ì„œ í™•ì • ê°€ëŠ¥
                    const isTieClickable = (auto?.autoReason === "TIE") && !!auto?.tieMembers?.length;
                    if (isTieClickable) {
                        rk.classList.add("clickable");
                        rk.title = "ë™ë¥ ì…ë‹ˆë‹¤. ëˆŒëŸ¬ì„œ ìµœì¢… ìˆœìœ„ë¥¼ í™•ì •í•˜ì„¸ìš”.";
                        rk.addEventListener("click", (e) => {
                            e.stopPropagation();
                            closeAssign();

                            openRankPortal({
                                teamId,
                                name: rowP,
                                tieMembers: auto.tieMembers,
                                baseRank: auto.tieBaseRank,
                                detail: f?.detail || "", // ìƒì„¸ ì„¤ëª… ì „ë‹¬
                                anchorEl: rk
                            });
                        });
                    }
                }

                tr.appendChild(rk);
                tbody.appendChild(tr);
            }

            tbl.appendChild(tbody);
            scroll.appendChild(tbl);
            wrap.appendChild(scroll);
            host.appendChild(wrap);
        }

        function renderAllTeams() {
            renderPool();
            const teamBoxes = teamsEl.querySelectorAll("[data-team-id]");
            teamBoxes.forEach(teamBox => {
                const teamId = teamBox.dataset.teamId;
                const members = getTeamMembers(teamId);
                teamBox.querySelector(".count").textContent = `${members.length}ëª…`;
                renderRoundRobin(teamBox, teamId, members);
            });
        }

        function moveToTeam(name, teamId) {
            if (!state.has(name)) return;
            state.set(name, { where: "team", teamId });
            renderAllTeams();
        }
        function moveToPool(name) {
            if (!state.has(name)) return;
            state.set(name, { where: "pool" });
            renderAllTeams();
        }

        function createTeams(groupCount) {
            teamsEl.innerHTML = "";
            teamInfoEl.textContent = `${groupCount}ì¡°`;
            state.groupsCount = groupCount;
            closeAssign();
            closeRank();

            for (let i = 1; i <= groupCount; i++) {
                const teamId = `team-${i}`;

                const box = document.createElement("div");
                box.className = "team droptarget";
                box.dataset.teamId = teamId;
                box.style.setProperty("--teamBg", TEAM_COLORS[(i - 1) % TEAM_COLORS.length]);

                const hd = document.createElement("div");
                hd.className = "hd";

                const tname = document.createElement("div");
                tname.className = "tname";
                tname.innerHTML = `<span>${i}ì¡°</span><span class="hint"></span>`;

                const count = document.createElement("div");
                count.className = "count";
                count.textContent = "0ëª…";

                hd.append(tname, count);

                const body = document.createElement("div");
                body.className = "body";
                const rrHost = document.createElement("div");
                rrHost.className = "rr-host";
                body.appendChild(rrHost);

                const footer = document.createElement("div");
                footer.className = "footer";

                const clearBtn = document.createElement("button");
                clearBtn.className = "linkbtn";
                clearBtn.textContent = "ì´ ì¡° ë¹„ìš°ê¸°";
                clearBtn.addEventListener("click", () => {
                    for (const nm of INITIAL_NAMES) {
                        const s = state.get(nm);
                        if (s?.where === "team" && s.teamId === teamId) {
                            state.set(nm, { where: "pool" });
                        }
                    }
                    // âœ… ìˆ˜ë™ í™•ì •ë„ í•¨ê»˜ ì´ˆê¸°í™”(í•´ë‹¹ ì¡°)
                    manualRankByTeam.delete(teamId);

                    renderAllTeams();
                });

                footer.append(clearBtn);

                box.append(hd, body, footer);

                makeDropTarget(box, (nm, evt) => {
                    const nearest = evt.target.closest(".team");
                    if (!nearest) return;
                    moveToTeam(nm, nearest.dataset.teamId);
                });

                teamsEl.appendChild(box);
            }

            renderAllTeams();
        }

        // pool íšŒìˆ˜ drop
        makeDropTarget(poolEl, (nm) => moveToPool(nm));

        document.querySelectorAll("button[data-g]").forEach(btn => {
            btn.addEventListener("click", () => createTeams(Number(btn.dataset.g)));
        });
        matchFormatEl.addEventListener("change", () => renderAllTeams());

        resetBtn.addEventListener("click", () => {
            initState();
            createTeams(0);
            renderAllTeams();
        });

        /* =========================================================
           TOURNAMENT GENERATION LOGIC (Integrated)
           ========================================================= */

        // 0) Common Utils
        function roundHalfUp(x) { return Math.round(x); }
        function nextPow2(n) { let p = 1; while (p < n) p *= 2; return p; }

        const SEED_POSITIONS = {
            2: [1, 2],
            4: [1, 4, 2, 3],
            8: [1, 8, 4, 5, 3, 6, 2, 7],
            16: [1, 16, 8, 9, 5, 12, 4, 13, 3, 14, 6, 11, 7, 10, 2, 15],
            32: [1, 32, 16, 17, 9, 24, 8, 25, 5, 28, 12, 21, 13, 20, 4, 29, 3, 30, 14, 19, 11, 22, 6, 27, 7, 26, 10, 23, 15, 18, 2, 31]
        };

        function splitUpperLower(groupRanks) {
            const upperEntries = [];
            const lowerEntries = [];
            for (const arr of groupRanks) {
                const n = arr.length;
                const upperCount = roundHalfUp(n / 2);
                for (let i = 0; i < upperCount; i++) upperEntries.push(arr[i]);
                for (let i = upperCount; i < n; i++) lowerEntries.push(arr[i]);
            }
            return { upperEntries, lowerEntries };
        }

        function normalizeTournamentRanks(entries) {
            const map = new Map();
            for (const e of entries) {
                if (!map.has(e.group)) map.set(e.group, []);
                map.get(e.group).push(e);
            }
            const out = [];
            for (const [g, list] of map.entries()) {
                list.forEach((e, idx) => out.push({ ...e, internalRank: idx + 1 }));
            }
            return out;
        }

        function makeSeedList(entries, groupCount) {
            const normalized = normalizeTournamentRanks(entries);

            const byRank = new Map();
            for (const q of normalized) {
                if (!byRank.has(q.internalRank)) byRank.set(q.internalRank, []);
                byRank.get(q.internalRank).push(q);
            }

            const ranks = Array.from(byRank.keys()).sort((a, b) => a - b);
            const seedList = [];

            for (const r of ranks) {
                const arr = byRank.get(r);
                // 1st place group order: 1, 2, 3 ...
                // 2nd place group order: optimized for 4-group to separate same-group meeting until Final
                // [2, 1, 4, 3] order puts G1-2nd in opposite half of G1-1st, etc.
                let groupOrder;
                if (r === 2 && groupCount === 4) {
                    groupOrder = [2, 1, 4, 3];
                } else {
                    groupOrder = Array.from({ length: groupCount }, (_, i) => i + 1);
                }

                const byGroup = new Map(arr.map(x => [x.group, x]));
                for (const g of groupOrder) {
                    if (byGroup.has(g)) seedList.push(byGroup.get(g));
                }
            }

            // Fallback for any missing items (rare)
            // Just add remaining
            // (Skipped for now, assuming standard full structure)

            return seedList.map((x, i) => ({ ...x, seed: i + 1 }));
        }

        function decideBracket(Q) {
            const B = nextPow2(Q);
            return { B, byes: B - Q };
        }

        function seedToSlots(seedList, B) {
            const pos = SEED_POSITIONS[B];
            if (!pos) {
                // If bracket size too big/small not in list, fallback or error. 
                // For this demo, let's support up to 32. 
                console.error("Not supported bracket size:", B);
                return { slots: [] };
            }
            const seedMap = new Map(seedList.map(s => [s.seed, s]));
            const slots = pos.map(seedNum => seedMap.get(seedNum) || null);
            return { slots };
        }

        function sameGroup(p1, p2) {
            if (!p1 || !p2) return false;
            return p1.group === p2.group;
        }

        // Try to avoid same group match in Round 1
        function avoidSameGroupRound1(matches) {
            for (let i = 0; i < matches.length; i++) {
                const m = matches[i];
                if (!sameGroup(m.p1, m.p2)) continue;

                let fixed = false;
                for (let j = 0; j < matches.length; j++) {
                    if (i === j) continue;
                    const n = matches[j];
                    if (!m.p1 || !m.p2 || !n.p1 || !n.p2) continue;

                    // candidates to swap
                    const candidates = [["p2", "p2"], ["p2", "p1"], ["p1", "p2"], ["p1", "p1"]];
                    for (const [aKey, bKey] of candidates) {
                        const mA = m[aKey];
                        const nB = n[bKey];

                        const newM1 = (aKey === "p1") ? nB : m.p1;
                        const newM2 = (aKey === "p2") ? nB : m.p2;
                        const newN1 = (bKey === "p1") ? mA : n.p1;
                        const newN2 = (bKey === "p2") ? mA : n.p2;

                        if (sameGroup(newM1, newM2)) continue;
                        if (sameGroup(newN1, newN2)) continue;

                        m[aKey] = nB;
                        n[bKey] = mA;
                        fixed = true;
                        break;
                    }
                    if (fixed) break;
                }
            }
            return matches;
        }

        function generateTournament(entries, groupCount) {
            const seeds = makeSeedList(entries, groupCount);
            const Q = seeds.length;

            if (Q === 0) return { Q, B: 0, seeds: [], slots: [] };
            if (Q === 1) return { Q, B: 1, seeds, slots: [seeds[0]] };

            const { B } = decideBracket(Q);
            const { slots } = seedToSlots(seeds, B);

            const matches = [];
            for (let i = 0; i < slots.length; i += 2) matches.push({ p1: slots[i], p2: slots[i + 1] });

            // Enabled by default
            const avoid = true;
            if (avoid) avoidSameGroupRound1(matches);

            return { Q, B, seeds, slots };
        }

        /* 
           Data Bridge: Collect Real Ranks from state
        */
        function collectRealGroupRanks() {
            const groupCount = state.groupsCount;
            const groupRanks = [];

            for (let g = 1; g <= groupCount; g++) {
                // FIXED: Must match createTeams ID format: "team-N"
                const teamId = `team-${g}`;
                const players = getTeamMembers(teamId);
                const autoPack = computeRanking(teamId, players);
                const finalPack = resolveFinalRanks(teamId, autoPack);

                // Build sortable list
                const list = [];
                for (const p of players) {
                    const f = finalPack.get(p);
                    // If manually ranked, use manual. If auto, use autoRank.
                    // Prioritize: manual > auto
                    let rk = 999;
                    if (f.finalRank !== null) {
                        rk = f.finalRank;
                    } else if (f.autoRank !== null) {
                        rk = f.autoRank;
                    }

                    // Display text (e.g. "1ì¡° 1ìœ„")
                    const labelText = `${g}ì¡° ${rk}ìœ„`;

                    list.push({
                        name: p,
                        rank: rk,
                        group: g,
                        label: labelText, // used for display
                        rankInGroup: rk   // used for sorting
                    });
                }

                // Sort by rank ascending
                list.sort((a, b) => a.rank - b.rank);
                groupRanks.push(list);
            }
            return groupRanks;
        }

        /* 
           Dashboard Renderer
        */
        function drawTournamentDashboard(groupRanks) {
            const el = document.getElementById("tm-dashboard");
            if (!el) return;

            const groupCount = groupRanks.length;

            // Generate HTML for Cards
            let cardsHtml = "";
            let totalUpper = 0;
            let totalLower = 0;

            groupRanks.forEach((grp, idx) => {
                const n = grp.length;
                const gNum = idx + 1;
                const up = roundHalfUp(n / 2);
                const low = n - up;

                totalUpper += up;
                totalLower += low;

                cardsHtml += `
                    <div class="tm-card">
                        <div class="row">
                            <span class="label">${gNum}ì¡°</span>
                            <span class="val">${n}ëª…</span>
                        </div>
                        <div class="desc">
                            ìƒìœ„ ${up}ëª… ì§„ì¶œ<br>
                            í•˜ìœ„ ${low}ëª… ì§„ì¶œ
                        </div>
                    </div>
                `;
            });

            // Decide Sizing Logic (Prediction)
            const upB = nextPow2(totalUpper);
            const lowB = nextPow2(totalLower);

            el.innerHTML = `
                <div class="tm-dash-header">
                    <h3>í† ë„ˆë¨¼íŠ¸ êµ¬ì„± ìš”ì•½</h3>
                    <span class="tm-pill">${groupCount}ê°œ ì¡°</span>
                    <span class="tm-pill">ê·œì¹™: ìƒìœ„=round(n/2)</span>
                    <label style="margin-left:auto; display:flex; align-items:center; gap:4px; font-size:13px; font-weight:700;">
                        <input type="checkbox" checked disabled> 1ë¼ìš´ë“œ ê°™ì€ ì¡° íšŒí”¼
                    </label>
                </div>
                <div class="tm-cards">
                    ${cardsHtml}
                </div>
                <div class="tm-dash-footer" style="flex-wrap:wrap; gap:10px;">
                    <div>
                        ìƒìœ„ ì§„ì¶œ ${totalUpper}ëª… â” ${upB}ê°• / 
                        í•˜ìœ„ ì§„ì¶œ ${totalLower}ëª… â” ${lowB}ê°• ì§„í–‰
                    </div>
                    <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
                        <button class="btn" onclick="captureResultImage()">ğŸ“· ì´ë¯¸ì§€ ì €ì¥</button>
                        <button class="btn" style="background:#0f9d58; color:#fff; border-color:#0b8043;" onclick="exportToGoogleSheet()">ğŸ“¤ ì„œë²„ì— ê²°ê³¼ì €ì¥</button>
                    </div>
                </div>
            `;
        }

        /* 
           UI & Engine 
        */
        function isBye(el) {
            if (!el) return false;
            if (el.classList.contains("bye")) return true;
            return (el.textContent || "").trim() === "BYE";
        }
        function isEmpty(el) {
            if (!el) return true;
            if (el.classList.contains("empty") && !el.classList.contains("bye")) return true;
            const t = (el.textContent || "").trim();
            return (t === "" || t === "?");
        }
        function hasPlayer(el) {
            if (!el) return false;
            if (isBye(el)) return false;
            if (isEmpty(el)) return false;
            // Check inner text ignoring small tag
            const t = el.innerText.replace(/\n.+/, "").trim();
            return t !== "" && t !== "?" && t !== "BYE";
        }

        function setNodeText(id, text, subText) {
            const el = document.getElementById(id);
            if (!el) return;
            // Use HTML to include rank info if available
            if (subText) {
                el.innerHTML = `${text}<small>${subText}</small>`;
            } else {
                el.innerHTML = text; // Fallback or BYE
            }
            el.classList.remove("empty");
            el.classList.remove("bye");
        }
        function setNodeEmpty(id) {
            const el = document.getElementById(id);
            if (!el) return;
            el.innerHTML = "?";
            el.classList.add("empty");
            el.classList.remove("bye");
        }

        function createTournamentLineEngine({ wrapEl, svg, prefix, direction, rounds, nodeId }) {
            const MATCHES = [];
            for (let r = 1; r <= rounds; r++) {
                const count = Math.pow(2, rounds - r + 1);
                if (r === rounds) {
                    MATCHES.push({ a: nodeId(r, 1), b: nodeId(r, 2), to: `${prefix}-winner` });
                } else {
                    for (let i = 1; i <= count; i += 2) {
                        MATCHES.push({ a: nodeId(r, i), b: nodeId(r, i + 1), to: nodeId(r + 1, Math.ceil(i / 2)) });
                    }
                }
            }

            function mkPath(d, from, to, seg) {
                const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
                p.setAttribute("d", d);
                p.dataset.from = from;
                p.dataset.to = to;
                p.dataset.seg = seg;
                return p;
            }

            function drawBracketLine(fromId1, fromId2, toId) {
                const fromEl1 = document.getElementById(fromId1);
                const fromEl2 = document.getElementById(fromId2);
                const toEl = document.getElementById(toId);
                if (!fromEl1 || !fromEl2 || !toEl) return;

                const wrapRect = wrapEl.getBoundingClientRect();
                const r1 = fromEl1.getBoundingClientRect();
                const r2 = fromEl2.getBoundingClientRect();
                const rt = toEl.getBoundingClientRect();

                const x1 = (direction === 1 ? r1.right : r1.left) - wrapRect.left;
                const y1 = (r1.top + r1.height / 2) - wrapRect.top;

                const x2 = (direction === 1 ? r2.right : r2.left) - wrapRect.left;
                const y2 = (r2.top + r2.height / 2) - wrapRect.top;

                const xt = (direction === 1 ? rt.left : rt.right) - wrapRect.left;
                const yt = (rt.top + rt.height / 2) - wrapRect.top;

                const topY = Math.min(y1, y2);
                const botY = Math.max(y1, y2);
                const joinY = Math.max(topY, Math.min(yt, botY));

                let joinX;
                if (direction === 1) {
                    const maxX = Math.max(x1, x2);
                    joinX = Math.min(xt - 24, maxX + 40);
                } else {
                    const minX = Math.min(x1, x2);
                    joinX = Math.max(xt + 24, minX - 40);
                }

                svg.appendChild(mkPath(`M ${x1} ${y1} H ${joinX}`, fromId1, toId, 'in'));
                svg.appendChild(mkPath(`M ${x2} ${y2} H ${joinX}`, fromId2, toId, 'in'));
                svg.appendChild(mkPath(`M ${joinX} ${topY} V ${joinY}`, `${fromId1}&${fromId2}`, toId, 'vTop'));
                svg.appendChild(mkPath(`M ${joinX} ${joinY} V ${botY}`, `${fromId1}&${fromId2}`, toId, 'vBot'));
                svg.appendChild(mkPath(`M ${joinX} ${joinY} H ${xt}`, `${fromId1}&${fromId2}`, toId, 'hOut'));
            }

            function clearStylesTo(toId) {
                svg.querySelectorAll(`path[data-to="${toId}"]`)
                    .forEach(p => p.classList.remove("win", "lose"));

                // Remove winner highlight from source nodes targeting this toId
                const relevant = MATCHES.filter(m => m.to === toId);
                relevant.forEach(m => {
                    const elA = document.getElementById(m.a);
                    const elB = document.getElementById(m.b);
                    if (elA) elA.classList.remove("winner");
                    if (elB) elB.classList.remove("winner");
                });
            }

            function centerYOf(id) {
                const el = document.getElementById(id);
                const wrapRect = wrapEl.getBoundingClientRect();
                const r = el.getBoundingClientRect();
                return (r.top + r.height / 2) - wrapRect.top;
            }

            function applyWinLoseStyles(a, b, to, winnerFrom) {
                const loserFrom = (winnerFrom === a) ? b : a;

                clearStylesTo(to);

                const winIn = svg.querySelector(`path[data-seg="in"][data-from="${winnerFrom}"][data-to="${to}"]`);
                const loseIn = svg.querySelector(`path[data-seg="in"][data-from="${loserFrom}"][data-to="${to}"]`);
                if (winIn) winIn.classList.add("win");
                if (loseIn) loseIn.classList.add("lose");

                // Node Highlight
                const winEl = document.getElementById(winnerFrom);
                const loseEl = document.getElementById(loserFrom);
                if (winEl) winEl.classList.add("winner");
                if (loseEl) loseEl.classList.remove("winner");

                const winnerIsTop = centerYOf(winnerFrom) < centerYOf(loserFrom);

                const vTop = svg.querySelector(`path[data-seg="vTop"][data-to="${to}"]`);
                const vBot = svg.querySelector(`path[data-seg="vBot"][data-to="${to}"]`);
                const hOut = svg.querySelector(`path[data-seg="hOut"][data-to="${to}"]`);

                if (hOut) hOut.classList.add("win");
                if (winnerIsTop) {
                    if (vTop) vTop.classList.add("win");
                    if (vBot) vBot.classList.add("lose");
                } else {
                    if (vBot) vBot.classList.add("win");
                    if (vTop) vTop.classList.add("lose");
                }
            }

            function restoreState() {
                for (const m of MATCHES) {
                    const toEl = document.getElementById(m.to);
                    // ì•„ì§ ìŠ¹ìê°€ ì—†ìœ¼ë©´ ìŠ¤í‚µ
                    if (!toEl || isEmpty(toEl) || isBye(toEl)) continue;

                    const aEl = document.getElementById(m.a);
                    const bEl = document.getElementById(m.b);
                    if (!aEl || !bEl) continue;

                    // ìŠ¹ì ì´ë¦„ í™•ì¸
                    const winnerName = extractName(toEl);
                    const nameA = extractName(aEl);
                    const nameB = extractName(bEl);

                    if (winnerName && winnerName === nameA) {
                        applyWinLoseStyles(m.a, m.b, m.to, m.a);
                    } else if (winnerName && winnerName === nameB) {
                        applyWinLoseStyles(m.a, m.b, m.to, m.b);
                    }
                }
            }

            function initLines() {
                svg.innerHTML = "";
                const w = wrapEl.clientWidth;
                const h = wrapEl.clientHeight;
                svg.setAttribute("width", w);
                svg.setAttribute("height", h);
                svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
                for (const m of MATCHES) drawBracketLine(m.a, m.b, m.to);

                // ì„ ì„ ë‹¤ì‹œ ê·¸ë¦° í›„, ìŠ¹ì ìƒíƒœí‘œì‹œ(ë¹¨ê°•/íšŒìƒ‰ ì„ ) ë³µêµ¬
                restoreState();
            }

            return { MATCHES, initLines, applyWinLoseStyles, clearStylesTo };
        }

        /* Interaction Logic */
        function clearDownstream({ startId, engine }) {
            for (const m of engine.MATCHES) {
                if (m.a === startId || m.b === startId) {
                    setNodeEmpty(m.to);
                    engine.clearStylesTo(m.to);
                    clearDownstream({ startId: m.to, engine });
                }
            }
        }

        function extractName(el) {
            // Safer extraction: Get the first text node (User Name)
            // ignoring <small> tag
            if (!el) return "";
            // Find first text node
            for (let i = 0; i < el.childNodes.length; i++) {
                if (el.childNodes[i].nodeType === Node.TEXT_NODE) {
                    return el.childNodes[i].textContent.trim();
                }
            }
            // fallback
            return el.innerText.split('\n')[0].trim();
        }

        function extractRankLabel(el) {
            const s = el.querySelector("small");
            return s ? s.innerText : "";
        }

        function advanceWinner({ a, b, to, clickedId, engine }) {
            const clickedEl = document.getElementById(clickedId);
            if (!clickedEl || !hasPlayer(clickedEl)) return;

            const targetEl = document.getElementById(to);
            if (!targetEl) return;

            const newValue = extractName(clickedEl);
            const newRank = extractRankLabel(clickedEl);

            const oldValue = extractName(targetEl);

            if (oldValue !== "?" && oldValue !== "" && oldValue !== "BYE" && oldValue !== newValue) {
                clearDownstream({ startId: to, engine });
            }

            setNodeText(to, newValue, newRank);
            engine.applyWinLoseStyles(a, b, to, clickedId);

            // Check for Final Result
            checkTournamentCompletion();
        }

        function autoAdvanceByes({ engine }) {
            let progressed = true;
            while (progressed) {
                progressed = false;

                for (const m of engine.MATCHES) {
                    const aEl = document.getElementById(m.a);
                    const bEl = document.getElementById(m.b);
                    const toEl = document.getElementById(m.to);
                    if (!aEl || !bEl || !toEl) continue;

                    const toIsEmpty = isEmpty(toEl) || isBye(toEl);
                    if (!toIsEmpty) continue;

                    const aHas = hasPlayer(aEl);
                    const bHas = hasPlayer(bEl);

                    const aIsByeFlag = isBye(aEl);
                    const bIsByeFlag = isBye(bEl);

                    if (aHas && bIsByeFlag) {
                        const nm = extractName(aEl);
                        const rk = extractRankLabel(aEl);
                        setNodeText(m.to, nm, rk);
                        engine.applyWinLoseStyles(m.a, m.b, m.to, m.a);
                        progressed = true;
                        continue;
                    }
                    if (bHas && aIsByeFlag) {
                        const nm = extractName(bEl);
                        const rk = extractRankLabel(bEl);
                        setNodeText(m.to, nm, rk);
                        engine.applyWinLoseStyles(m.a, m.b, m.to, m.b);
                        progressed = true;
                        continue;
                    }
                }
            }
            // Check for Final Result
            checkTournamentCompletion();
        }

        const resizeHandlers = {}; // { U: func, L: func }

        function createBracketUI({ wrapId, svgId, prefix, direction, B, slots, titleElId, titleText }) {
            const wrapEl = document.getElementById(wrapId);
            const svg = document.getElementById(svgId);
            const titleEl = document.getElementById(titleElId);

            wrapEl.querySelectorAll(".tm-player, .tm-champ-label").forEach(el => el.remove());
            svg.innerHTML = "";

            if (B < 2) {
                titleEl.textContent = titleText + " (ìƒì„± ë¶ˆê°€)";
                return;
            }

            titleEl.textContent = `${titleText} (${B}ê°•, BYE ${slots.filter(x => x === null).length}ê°œ)`;

            // âœ… Dynamic Height: Prevent overlap (B=16 needs ~960px)
            const minH = Math.max(600, B * 55 + 60);
            wrapEl.style.height = `${minH}px`;

            const W = wrapEl.clientWidth;
            const H = wrapEl.clientHeight;
            const boxW = 110, boxH = 42; // Increased H
            const champW = 130;

            const rounds = Math.log2(B);
            const padX = 20;
            const champX = W - padX - champW;
            const step = (champX - padX) / rounds;

            const padY = 20;
            const usableH = H - padY * 2;

            const nodeId = (r, i) => `${prefix}-r${r}-${i}`;

            for (let r = 1; r <= rounds; r++) {
                const count = B / Math.pow(2, r - 1);
                const spacing = usableH / count;
                const xLTR = padX + (r - 1) * step;

                for (let i = 1; i <= count; i++) {
                    const y = padY + (i - 0.5) * spacing - boxH / 2;

                    const div = document.createElement("div");
                    div.className = "tm-player empty";
                    div.id = nodeId(r, i);
                    div.textContent = "?";

                    const x = (direction === 1)
                        ? xLTR
                        : (W - xLTR - boxW);

                    div.style.left = `${x}px`;
                    div.style.top = `${y}px`;

                    if (r < rounds) {
                        const isOdd = (i % 2 === 1);
                        div.dataset.a = nodeId(r, isOdd ? i : i - 1);
                        div.dataset.b = nodeId(r, isOdd ? i + 1 : i);
                        div.dataset.to = nodeId(r + 1, Math.ceil(i / 2));
                    } else {
                        div.dataset.a = nodeId(rounds, 1);
                        div.dataset.b = nodeId(rounds, 2);
                        div.dataset.to = `${prefix}-winner`;
                    }

                    wrapEl.appendChild(div);
                }
            }

            const champ = document.createElement("div");
            champ.className = "tm-champ-label";
            champ.style.top = `${(H / 2) - 55}px`;
            champ.style.left = (direction === 1) ? `${champX}px` : `${padX}px`;
            champ.innerHTML = `
                <div class="label">CHAMPION</div>
                <div id="${prefix}-winner" class="tm-player empty tm-winner-box" style="position:static; cursor:pointer;">?</div>
            `;
            wrapEl.appendChild(champ);

            const winnerEl = document.getElementById(`${prefix}-winner`);
            winnerEl.dataset.a = nodeId(rounds, 1);
            winnerEl.dataset.b = nodeId(rounds, 2);
            winnerEl.dataset.to = `${prefix}-winner`;

            for (let i = 1; i <= B; i++) {
                const el = document.getElementById(nodeId(1, i));
                const p = slots[i - 1];
                if (!p) {
                    el.textContent = "BYE";
                    el.classList.add("bye");
                    el.classList.add("empty");
                    continue;
                }
                // ! Display Name + Rank Label
                el.innerHTML = `${p.name}<small>${p.label}</small>`;
                el.classList.remove("empty");
                el.classList.remove("bye");
            }

            const engine = createTournamentLineEngine({ wrapEl, svg, prefix, direction, rounds, nodeId });
            autoAdvanceByes({ engine });

            wrapEl.addEventListener("click", (e) => {
                const box = e.target.closest(".tm-player");
                if (!box || !wrapEl.contains(box)) return;

                const a = box.dataset.a;
                const b = box.dataset.b;
                const to = box.dataset.to;

                if (box.id === `${prefix}-winner`) {
                    const fa = document.getElementById(a);
                    const fb = document.getElementById(b);
                    if (!fa || !fb) return;

                    const aHas = hasPlayer(fa);
                    const bHas = hasPlayer(fb);
                    if (!aHas && !bHas) return;

                    const current = extractName(box);

                    if (aHas && !bHas) {
                        advanceWinner({ a, b, to, clickedId: a, engine });
                    } else if (!aHas && bHas) {
                        advanceWinner({ a, b, to, clickedId: b, engine });
                    } else {
                        const aName = extractName(fa);
                        const bName = extractName(fb);
                        const pickId = (current === aName) ? b : a;
                        advanceWinner({ a, b, to, clickedId: pickId, engine });
                    }

                    autoAdvanceByes({ engine });
                    return;
                }

                if (isEmpty(box) || isBye(box)) return;
                if (!a || !b || !to) return;

                advanceWinner({ a, b, to, clickedId: box.id, engine });
                autoAdvanceByes({ engine });
            }, { passive: true });

            // âœ… Resize Handler Management
            if (resizeHandlers[prefix]) {
                window.removeEventListener("resize", resizeHandlers[prefix]);
            }
            const onResize = () => engine.initLines();
            window.addEventListener("resize", onResize);
            resizeHandlers[prefix] = onResize;

            engine.initLines();
        }

        /* 
           Main Execution: Generate Tournament from actual state
        */
        function runTournamentGeneration() {
            const groupRanks = collectRealGroupRanks();

            // Check total players
            let totalPlayers = 0;
            for (const g of groupRanks) totalPlayers += g.length;

            if (totalPlayers === 0) {
                alert("ì¡°ì— ë°°ì •ëœ ì„ ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤! \n[ì´ë¦„ ì¹´ë“œ]ë¥¼ í´ë¦­í•˜ê±°ë‚˜ ë“œë˜ê·¸í•˜ì—¬ ì¡°ì— ë°°ì •í•œ ë’¤ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
                return;
            }

            const groupCount = groupRanks.length;

            // âœ… Validation: Check if all ranks are decided and unique
            const invalidGroups = [];
            for (let i = 0; i < groupCount; i++) {
                const grp = groupRanks[i];
                const gNum = i + 1;

                // 1. Check for unranked players (rank 999)
                const unranked = grp.filter(p => p.rank === 999);
                if (unranked.length > 0) {
                    invalidGroups.push(`${gNum}ì¡° (ê²½ê¸° ê²°ê³¼ ì—†ìŒ)`);
                    continue;
                }

                // 2. Check for duplicates (Ties)
                const ranks = grp.map(p => p.rank);
                const uniqueRanks = new Set(ranks);
                if (uniqueRanks.size !== ranks.length) {
                    // Find duplicate ranks
                    const counts = {};
                    ranks.forEach(r => counts[r] = (counts[r] || 0) + 1);
                    const dups = Object.keys(counts).filter(r => counts[r] > 1);
                    invalidGroups.push(`${gNum}ì¡° (ë™ë¥ : ${dups.map(r => r + 'ìœ„').join(', ')})`);
                }
            }

            if (invalidGroups.length > 0) {
                alert(`ëª¨ë“  ì¡°ì˜ ê²°ê³¼ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.\n(ì•„ì§ ìˆœìœ„ê°€ ê²°ì •ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ë™ë¥ ì¸ ì¡°ê°€ ìˆìŠµë‹ˆë‹¤.)\n\në¬¸ì œê°€ ìˆëŠ” ì¡°:\n${invalidGroups.join(", ")}`);
                return;
            }

            // Basic Split: n/2
            const { upperEntries, lowerEntries } = splitUpperLower(groupRanks);

            // Draw Dashboard
            drawTournamentDashboard(groupRanks);

            // Generate
            const upper = generateTournament(upperEntries, groupCount);
            const lower = generateTournament(lowerEntries, groupCount);

            // Show UI first to ensure layout is calculated
            const area = document.getElementById("tournament-area");
            area.style.display = "flex";

            // Wait for layout to apply before measuring dimensions
            // Increased to 200ms to ensure container is fully rendered
            setTimeout(() => {
                createBracketUI({
                    wrapId: "tm-wrap-upper",
                    svgId: "tm-lines-upper",
                    prefix: "U",
                    direction: 1,
                    B: upper.B,
                    slots: upper.slots,
                    titleElId: "tm-titleUpper",
                    titleText: "ìƒìœ„ í† ë„ˆë¨¼íŠ¸"
                });

                createBracketUI({
                    wrapId: "tm-wrap-lower",
                    svgId: "tm-lines-lower",
                    prefix: "L",
                    direction: -1,
                    B: lower.B,
                    slots: lower.slots,
                    titleElId: "tm-titleLower",
                    titleText: "í•˜ìœ„ í† ë„ˆë¨¼íŠ¸"
                });

                // Scroll to tournament area
                area.scrollIntoView({ behavior: 'smooth' });
            }, 200);
        }

        // Expose button logic
        document.getElementById("btn-gen-tournament").addEventListener("click", runTournamentGeneration);

        // ============================================
        //  ğŸ† Final Result Summary Logic
        // ============================================
        function getRankers(prefix) {
            // Helper to get text content safer
            const getName = (id) => {
                const el = document.getElementById(id);
                return (el && hasPlayer(el)) ? extractName(el) : null;
            };

            // 1. Calculate Max Round
            let maxR = 0;
            for (let r = 1; r <= 8; r++) {
                if (document.getElementById(`${prefix}-r${r}-1`)) maxR = r;
            }
            if (maxR === 0) return null;

            // 2. Winner
            const winnerId = `${prefix}-winner`;
            const winnerName = getName(winnerId);
            if (!winnerName) return null;

            // 3. Finalists (Round N)
            const finalists = [];
            const f1 = getName(`${prefix}-r${maxR}-1`);
            const f2 = getName(`${prefix}-r${maxR}-2`);
            if (f1) finalists.push(f1);
            if (f2) finalists.push(f2);

            // 4. Runner Up
            let runnerUpName = "";
            const found = finalists.find(n => n !== winnerName);
            if (found) runnerUpName = found;

            // 5. Semi-Finalists (3rd Place) - Players in Round N-1 not in finalists
            const semiLosers = [];
            if (maxR > 1) {
                const semiR = maxR - 1;
                for (let k = 1; k <= 4; k++) {
                    const p = getName(`${prefix}-r${semiR}-${k}`);
                    if (p && !finalists.includes(p)) {
                        semiLosers.push(p);
                    }
                }
            }

            return {
                winner: winnerName,
                runnerUp: runnerUpName || "",
                third: semiLosers.join(", ")
            };
        }

        function getLoserOf(matchId, winnerName) {
            const mEl = document.getElementById(matchId);
            if (!mEl) return null;
            const aId = mEl.dataset.a;
            const bId = mEl.dataset.b;
            if (!aId || !bId) return null;

            const nameA = extractName(document.getElementById(aId));
            const nameB = extractName(document.getElementById(bId));

            if (winnerName === nameA) return nameB;
            if (winnerName === nameB) return nameA;
            return null;
        }

        function checkTournamentCompletion() {
            const uRank = getRankers("U");
            const lRank = getRankers("L");

            if (uRank && lRank) {
                // Determine Upper
                document.getElementById("sum-u-1").textContent = uRank.winner;
                document.getElementById("sum-u-2").textContent = uRank.runnerUp;
                document.getElementById("sum-u-3").textContent = uRank.third || "-"; // 3rd might be empty if tiny bracket

                // Determine Lower
                document.getElementById("sum-l-1").textContent = lRank.winner;
                document.getElementById("sum-l-2").textContent = lRank.runnerUp;

                const summaryEl = document.getElementById("final-summary");
                summaryEl.classList.add("show");

                // Optional: Scroll to top of summary if not visible
                // summaryEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        /* 
           Sample Tournament Logic 
        */
        function runSampleTournament() {
            // Mock Data: 4 Groups, 5 Players each
            const groupCount = 4;
            const groupRanks = [];
            for (let g = 1; g <= groupCount; g++) {
                const list = [];
                for (let r = 1; r <= 5; r++) {
                    list.push({
                        name: `ì„ ìˆ˜ ${g}-${r}`,
                        rank: r,
                        group: g,
                        label: `${g}ì¡° ${r}ìœ„`,
                        rankInGroup: r
                    });
                }
                groupRanks.push(list);
            }

            // Draw Dashboard
            drawTournamentDashboard(groupRanks);

            const { upperEntries, lowerEntries } = splitUpperLower(groupRanks);
            const upper = generateTournament(upperEntries, groupCount);
            const lower = generateTournament(lowerEntries, groupCount);

            const area = document.getElementById("tournament-area");
            area.style.display = "flex";

            setTimeout(() => {
                createBracketUI({
                    wrapId: "tm-wrap-upper",
                    svgId: "tm-lines-upper",
                    prefix: "U",
                    direction: 1,
                    B: upper.B,
                    slots: upper.slots,
                    titleElId: "tm-titleUpper",
                    titleText: "ìƒìœ„ í† ë„ˆë¨¼íŠ¸ (ì˜ˆì‹œ)"
                });

                createBracketUI({
                    wrapId: "tm-wrap-lower",
                    svgId: "tm-lines-lower",
                    prefix: "L",
                    direction: -1,
                    B: lower.B,
                    slots: lower.slots,
                    titleElId: "tm-titleLower",
                    titleText: "í•˜ìœ„ í† ë„ˆë¨¼íŠ¸ (ì˜ˆì‹œ)"
                });
                area.scrollIntoView({ behavior: 'smooth' });
            }, 50);
        }
        document.getElementById("btn-show-sample").addEventListener("click", runSampleTournament);

        function runAutoTestScenario() {
            if (!confirm("í˜„ì¬ ë°ì´í„°ë¥¼ ëª¨ë‘ ì§€ìš°ê³  í…ŒìŠ¤íŠ¸ ë°ì´í„°ë¥¼ ìƒì„±í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;

            initState();

            // 1. 3 Teams
            createTeams(3);

            // 2. Assign 5 players each
            // Ensure we have enough names
            if (INITIAL_NAMES.length < 15) {
                alert("ì´ë¦„ì´ ë¶€ì¡±í•©ë‹ˆë‹¤ (ìµœì†Œ 15ëª… í•„ìš”)");
                return;
            }

            const pools = [
                INITIAL_NAMES.slice(0, 5),
                INITIAL_NAMES.slice(5, 10),
                INITIAL_NAMES.slice(10, 15)
            ];

            pools.forEach((members, grpIdx) => {
                const teamId = `team-${grpIdx + 1}`;
                members.forEach(nm => {
                    state.set(nm, { where: "team", teamId });
                });

                // 3. Generate Results (Perfect Rankings 1..5)
                // members[0] wins all -> 1st
                // members[1] wins rest -> 2nd
                // ...
                const resMap = ensureTeamResults(teamId);

                for (let i = 0; i < members.length; i++) {
                    for (let j = i + 1; j < members.length; j++) {
                        const winner = members[i];
                        const loser = members[j];

                        const k = keyPair(winner, loser);
                        // winner is 'a' if k starts with winner
                        const isWinnerFirst = k.startsWith(winner + "|||");

                        // Score 2-0 for winner
                        const val = isWinnerFirst ? "2-0" : "0-2";
                        resMap.set(k, { score: val });
                    }
                }
            });

            renderAllTeams();

            // 4. Draw Tournament
            setTimeout(runTournamentGeneration, 100);
        }

        function runAutoTestScenario4Groups() {
            if (!confirm("í˜„ì¬ ë°ì´í„°ë¥¼ ëª¨ë‘ ì§€ìš°ê³  4ê°œ ì¡°(4,5,4,4ëª…) ëœë¤ ì ìˆ˜ í…ŒìŠ¤íŠ¸ë¥¼ ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;

            initState();

            // 1. 4 Teams
            createTeams(4);

            // 2. Assign players (4, 5, 4, 4 = 17 total)
            if (INITIAL_NAMES.length < 17) {
                alert("ì´ë¦„ì´ ë¶€ì¡±í•©ë‹ˆë‹¤ (ìµœì†Œ 17ëª… í•„ìš”)");
                return;
            }

            // Shuffle names slightly for randomness if desired, but simple slice is fine for test.
            // Let's just take first 17.
            // But to make it more random-like, we use random scores.
            const p1 = INITIAL_NAMES.slice(0, 4);
            const p2 = INITIAL_NAMES.slice(4, 9);
            const p3 = INITIAL_NAMES.slice(9, 13);
            const p4 = INITIAL_NAMES.slice(13, 17);

            const pools = [p1, p2, p3, p4];

            pools.forEach((members, grpIdx) => {
                const teamId = `team-${grpIdx + 1}`;
                members.forEach(nm => {
                    state.set(nm, { where: "team", teamId });
                });

                // 3. Generate Random Results
                const resMap = ensureTeamResults(teamId);

                for (let i = 0; i < members.length; i++) {
                    for (let j = i + 1; j < members.length; j++) {
                        const A = members[i];
                        const B = members[j];
                        const k = keyPair(A, B);

                        // Random score: 2-0, 0-2, 2-1, 1-2
                        // Weighted random? Or just pure random.
                        // Let's make it somewhat interesting.
                        const r = Math.random();
                        let scoreVal = "2-0";
                        if (r < 0.25) scoreVal = "2-0";
                        else if (r < 0.5) scoreVal = "0-2";
                        else if (r < 0.75) scoreVal = "2-1";
                        else scoreVal = "1-2";

                        resMap.set(k, { score: scoreVal });
                    }
                }
            });

            renderAllTeams();

            // 4. Draw Tournament
            setTimeout(runTournamentGeneration, 100);
        }

        // init
        initState();
        renderPool();
        createTeams(4);

        async function exportToGoogleSheet() {
            // Hardcoded Default URL
            const url = "https://script.google.com/macros/s/AKfycbybkNRimOGBcCYH7HAbiT6lhlqtT9SzVZ0QjDxkD6By1ePgtv5XS8-eGSIIRocNpdJn/exec";

            // 1. Calculate Points
            const today = new Date().toISOString().split('T')[0];
            const pointMap = new Map(); // name -> {points, type, details[]}

            // (1) Attendance (+2)
            let entries = [];
            state.forEach((val, key) => {
                if (val.where === 'team') entries.push(key);
            });

            entries.forEach(name => {
                pointMap.set(name, { points: 2, type: "ì°¸ê°€", details: ["ì°¸ê°€(+2)"] });
            });

            // (2) Tournament Results
            function addPointByName(name, bonus, label) {
                if (!name || name === 'ë¯¸ì •') return;
                if (!pointMap.has(name)) pointMap.set(name, { points: 2, type: "ì°¸ê°€", details: ["ì°¸ê°€(+2)"] });
                const p = pointMap.get(name);
                p.points += bonus;
                p.details.push(`${label}(+${bonus})`);

                if (label.includes("ìš°ìŠ¹")) p.type = label;
                else if (label.includes("ì¤€ìš°ìŠ¹") && !p.type.includes("ìš°ìŠ¹")) p.type = label;
            }

            // Shared logic to find rankers
            function analyzeBracket(prefix) {
                let maxR = 0;
                for (let r = 1; r <= 6; r++) if (document.getElementById(`${prefix}-r${r}-1`)) maxR = r;
                if (maxR === 0) return { winner: 'ë¯¸ì •', runnerUp: 'ë¯¸ì •', semiFinalists: [] };

                // Winner
                const winEl = document.getElementById(`${prefix}-winner`);
                const winner = (winEl && hasPlayer(winEl)) ? extractName(winEl) : 'ë¯¸ì •';

                // Runner Up
                let runnerUp = 'ë¯¸ì •';
                const f1 = document.getElementById(`${prefix}-r${maxR}-1`);
                const f2 = document.getElementById(`${prefix}-r${maxR}-2`);
                const finalists = [];
                if (f1 && hasPlayer(f1)) finalists.push(extractName(f1));
                if (f2 && hasPlayer(f2)) finalists.push(extractName(f2));

                if (winner !== 'ë¯¸ì •') {
                    const found = finalists.find(n => n !== winner);
                    if (found) runnerUp = found;
                }

                // Semi-Finalists (Joint 3rd) - exclude finalists
                const semiFinalists = [];
                if (maxR > 1) {
                    const semiR = maxR - 1;
                    for (let k = 1; k <= 4; k++) {
                        const sEl = document.getElementById(`${prefix}-r${semiR}-${k}`);
                        if (sEl && hasPlayer(sEl)) {
                            const name = extractName(sEl);
                            if (!finalists.includes(name)) {
                                semiFinalists.push(name);
                            }
                        }
                    }
                }
                return { winner, runnerUp, semiFinalists };
            }

            // Apply Points
            const upper = analyzeBracket('U');
            if (upper.winner !== 'ë¯¸ì •') {
                addPointByName(upper.winner, 5, "ìƒìœ„ ìš°ìŠ¹");
                addPointByName(upper.runnerUp, 4, "ìƒìœ„ ì¤€ìš°ìŠ¹");
                upper.semiFinalists.forEach(name => addPointByName(name, 3, "ìƒìœ„ 4ê°•"));
            }

            const lower = analyzeBracket('L');
            if (lower.winner !== 'ë¯¸ì •') {
                addPointByName(lower.winner, 4, "í•˜ìœ„ ìš°ìŠ¹");
                addPointByName(lower.runnerUp, 3, "í•˜ìœ„ ì¤€ìš°ìŠ¹");
                // Lower semi? If needed: lower.semiFinalists.forEach(name => addPointByName(name, 0, "í•˜ìœ„ 4ê°•"));
            }

            // 2. Prepare Payload
            const results = [];
            pointMap.forEach((val, name) => {
                results.push({
                    name: name,
                    type: val.type,
                    points: val.points,
                    detail: val.details.join(", ")
                });
            });

            if (results.length === 0) {
                alert("ì „ì†¡í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. (ì°¸ê°€ìê°€ ì—†ê±°ë‚˜ í† ë„ˆë¨¼íŠ¸ ë¯¸ìƒì„±)");
                return;
            }

            // 3. Confirm via Modal
            const confirmList = [];
            // Detailed Confirmation
            if (upper.winner !== 'ë¯¸ì •') {
                confirmList.push(`ğŸ† ìƒìœ„ ìš°ìŠ¹: <b>${upper.winner}</b>`);
                confirmList.push(`ğŸ¥ˆ ìƒìœ„ ì¤€ìš°ìŠ¹: <b>${upper.runnerUp}</b>`);
                if (upper.semiFinalists.length > 0) confirmList.push(`ğŸ¥‰ ìƒìœ„ 4ê°•: ${upper.semiFinalists.join(', ')}`);
            }
            if (lower.winner !== 'ë¯¸ì •') {
                confirmList.push(`ğŸ† í•˜ìœ„ ìš°ìŠ¹: <b>${lower.winner}</b>`);
                confirmList.push(`ğŸ¥ˆ í•˜ìœ„ ì¤€ìš°ìŠ¹: <b>${lower.runnerUp}</b>`);
            }
            confirmList.push(`ì´ <b>${results.length}ëª…</b>ì˜ ê¸°ë¡ì„ ì „ì†¡í•©ë‹ˆë‹¤.`);

            openConfirmModal({
                title: "êµ¬ê¸€ ì‹œíŠ¸ ì €ì¥",
                message: "ì•„ë˜ ë‚´ìš©ìœ¼ë¡œ ì„œë²„ì— ì „ì†¡í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                list: confirmList,
                onConfirm: async () => {
                    try {
                        toggleLoading(true, "ì„œë²„ì— ì „ì†¡ ì¤‘...");
                        const payload = {
                            date: today,
                            results: results
                        };

                        await fetch(url, {
                            method: "POST",
                            mode: "no-cors",
                            headers: { "Content-Type": "text/plain" },
                            body: JSON.stringify(payload)
                        });

                        alert("âœ… ê¸°ë¡ì´ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤! (êµ¬ê¸€ ì‹œíŠ¸ í™•ì¸)");

                    } catch (e) {
                        console.error(e);
                        alert("ì „ì†¡ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: " + e.message);
                    } finally {
                        toggleLoading(false);
                    }
                }
            });
        }

        /* âœ… Helper: Loading Overlay */
        function toggleLoading(show, msg = "ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤...") {
            const el = document.getElementById("loadingOverlay");
            const txt = document.getElementById("loadingText");
            if (show) {
                txt.textContent = msg;
                el.classList.add("open");
            } else {
                el.classList.remove("open");
            }
        }

        /* âœ… Helper: Custom Confirm Modal */
        function openConfirmModal({ title, message, list, onConfirm }) {
            const portal = document.getElementById("customModal");
            const titleEl = document.getElementById("modalTitle");
            const msgEl = document.getElementById("modalMessage");
            const listEl = document.getElementById("modalList");
            const cancelBtn = document.getElementById("modalCancelBtn");
            const confirmBtn = document.getElementById("modalConfirmBtn");

            titleEl.textContent = title || "ì•Œë¦¼";
            msgEl.innerHTML = message || "";

            if (list && list.length > 0) {
                listEl.style.display = "block";
                listEl.innerHTML = list.map(item => `<li>${item}</li>`).join("");
            } else {
                listEl.style.display = "none";
                listEl.innerHTML = "";
            }

            const close = () => {
                portal.classList.remove("open");
                cancelBtn.onclick = null;
                confirmBtn.onclick = null;
            };

            cancelBtn.onclick = close;
            confirmBtn.onclick = () => {
                close();
                if (onConfirm) onConfirm();
            };

            portal.classList.add("open");
        }

        /* âœ… Helper: Image Capture */
        async function captureResultImage() {
            const area = document.getElementById("tournament-area");
            if (!area || area.style.display === "none") {
                alert("í† ë„ˆë¨¼íŠ¸ ê²°ê³¼ê°€ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
                return;
            }

            // 1. Show Loading Overlay (Cover the mess we are about to make)
            toggleLoading(true, "ì´ë¯¸ì§€ ìƒì„± ì¤‘... (ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”)");
            await new Promise(r => setTimeout(r, 100)); // Render tick

            // 2. Store Original States & Modify Real DOM (To ensure correct height calculation)
            // We use a class approach or direct style manipulation. Direct style is safer for restoration without CSS conflicts.
            const originalStyles = new Map();

            function hide(id) {
                const el = document.getElementById(id);
                if (el) {
                    originalStyles.set(el, { property: 'display', value: el.style.display });
                    el.style.display = "none";
                }
            }
            function expand(el) {
                originalStyles.set(el, {
                    overflow: el.style.overflow,
                    height: el.style.height,
                    maxHeight: el.style.maxHeight
                });
                el.style.overflow = "visible";
                el.style.height = "auto";
                el.style.maxHeight = "none";
            }

            try {
                // Execute Layout Changes on Real DOM
                hide("card-settings");
                hide("card-pool");
                // Note: We DO NOT hide "loadingOverlay" here, because we want the user to see it.
                // We will hide it inside onclone so it's not in the screenshot.

                // Hide Portals
                document.querySelectorAll(".portal, .modal-portal").forEach(el => {
                    originalStyles.set(el, { property: 'display', value: el.style.display });
                    el.style.display = "none";
                });

                // Expand Tables
                document.querySelectorAll(".table-scroll").forEach(el => expand(el));

                // Force layout recalc?
                // accessing offsetHeight forces reflow
                document.body.offsetHeight;

                // 3. Capture
                const canvas = await html2canvas(document.body, {
                    scale: 2,
                    backgroundColor: "#ffffff", // Force white background
                    useCORS: true,
                    logging: false,
                    onclone: (clonedDoc) => {
                        // A. Hide the overlay in the screenshot
                        const overlay = clonedDoc.getElementById("loadingOverlay");
                        if (overlay) overlay.style.display = "none";

                        // B. Force Text Color Black (Global & Specific)
                        clonedDoc.body.style.color = "#000000";
                        clonedDoc.body.style.backgroundColor = "#ffffff";

                        // D. Clean up Header Date (Remove underline, force black)
                        const headerDate = clonedDoc.getElementById("headerDate");
                        if (headerDate) {
                            headerDate.style.borderBottom = "none";
                            headerDate.style.color = "#000000";
                            headerDate.style.fontWeight = "800";
                        }

                        // C. Replace Selects with Text (Visual correction)
                        const originSelects = document.body.querySelectorAll("select");
                        const clonedSelects = clonedDoc.querySelectorAll("select");

                        originSelects.forEach((orig, idx) => {
                            if (clonedSelects[idx]) {
                                const val = orig.options[orig.selectedIndex]?.text || " - ";
                                // Create span
                                const span = clonedDoc.createElement("span");
                                span.textContent = val;
                                span.style.fontWeight = "bold";
                                span.style.fontSize = "14px";
                                span.style.color = "#000000"; // Force black
                                span.style.display = "flex";
                                span.style.alignItems = "center";
                                span.style.justifyContent = "center";

                                if (clonedSelects[idx].parentNode) {
                                    clonedSelects[idx].parentNode.replaceChild(span, clonedSelects[idx]);
                                }
                            }
                        });

                        // Ensure all text is black by brute-forcing some common containers if inheritance fails?
                        // Usually body style is enough, but some user agent styles might override.
                        // Let's rely on body.style.color + explicit span colors for now.
                    }
                });

                // 4. Download
                const link = document.createElement("a");
                link.download = `ëŒ€ì§„í‘œ_ê²°ê³¼_${new Date().toISOString().slice(0, 10)}.png`;
                link.href = canvas.toDataURL("image/png");
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

            } catch (err) {
                console.error(err);
                alert("ì´ë¯¸ì§€ ì €ì¥ ì‹¤íŒ¨: " + err.message);
            } finally {
                // 5. Restore Real DOM
                originalStyles.forEach((styles, el) => {
                    if (styles.property) {
                        el.style[styles.property] = styles.value;
                    } else {
                        // Restoring expanded styles
                        el.style.overflow = styles.overflow;
                        el.style.height = styles.height;
                        el.style.maxHeight = styles.maxHeight;
                    }
                });

                toggleLoading(false);
            }
        }
    </script>
</body>

</html>